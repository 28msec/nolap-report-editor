angular.module('excelParser', []).factory('ExcelParser',function(){ return (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = peg$FAILED,
        peg$c1 = function(left, operator, right) { return create(operator, left, right); },
        peg$c2 = /^[+\-]/,
        peg$c3 = { type: "class", value: "[+\\-]", description: "[+\\-]" },
        peg$c4 = function(sign) { if (sign === "+"){ return "add"; } else { return "sub"; } },
        peg$c5 = /^[*\/]/,
        peg$c6 = { type: "class", value: "[*\\/]", description: "[*\\/]" },
        peg$c7 = function(sign) { if (sign === "*"){ return "mul"; } else { return "div"; } },
        peg$c8 = /^[<>]/,
        peg$c9 = { type: "class", value: "[<>]", description: "[<>]" },
        peg$c10 = "=",
        peg$c11 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c12 = function(double) { switch(double.join("")){
                                   case "<=": return "le";
                                   case ">=": return "ge";
                                 };
                               },
        peg$c13 = "<>",
        peg$c14 = { type: "literal", value: "<>", description: "\"<>\"" },
        peg$c15 = function() { return "ne"; },
        peg$c16 = /^[<=>]/,
        peg$c17 = { type: "class", value: "[<=>]", description: "[<=>]" },
        peg$c18 = function(single) { switch(single){
                             case "=": return "eq";
                             case "<": return "lt";
                             case ">": return "gt";
                           };
                         },
        peg$c19 = "(",
        peg$c20 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c21 = ")",
        peg$c22 = { type: "literal", value: ")", description: "\")\"" },
        peg$c23 = function(block) { return createOne("block", block); },
        peg$c24 = /^[Tt]/,
        peg$c25 = { type: "class", value: "[Tt]", description: "[Tt]" },
        peg$c26 = /^[Rr]/,
        peg$c27 = { type: "class", value: "[Rr]", description: "[Rr]" },
        peg$c28 = /^[Uu]/,
        peg$c29 = { type: "class", value: "[Uu]", description: "[Uu]" },
        peg$c30 = /^[Ee]/,
        peg$c31 = { type: "class", value: "[Ee]", description: "[Ee]" },
        peg$c32 = function() { return createAtomic('boolean', 'true'); },
        peg$c33 = /^[Ff]/,
        peg$c34 = { type: "class", value: "[Ff]", description: "[Ff]" },
        peg$c35 = /^[Aa]/,
        peg$c36 = { type: "class", value: "[Aa]", description: "[Aa]" },
        peg$c37 = /^[Ll]/,
        peg$c38 = { type: "class", value: "[Ll]", description: "[Ll]" },
        peg$c39 = /^[Ss]/,
        peg$c40 = { type: "class", value: "[Ss]", description: "[Ss]" },
        peg$c41 = function() { return createAtomic('boolean', 'false'); },
        peg$c42 = [],
        peg$c43 = /^[a-zA-Z0-9._]/,
        peg$c44 = { type: "class", value: "[a-zA-Z0-9._]", description: "[a-zA-Z0-9._]" },
        peg$c45 = void 0,
        peg$c46 = /^[^(]/,
        peg$c47 = { type: "class", value: "[^(]", description: "[^(]" },
        peg$c48 = function(name) { return createVar(name[0].join("")); },
        peg$c49 = function(name) { return createVar(name.join("")); },
        peg$c50 = { type: "other", description: "integer" },
        peg$c51 = /^[0-9.]/,
        peg$c52 = { type: "class", value: "[0-9.]", description: "[0-9.]" },
        peg$c53 = function(digits) { return createAtomic('numeric', parseFloat(digits.join(""), 10)); },
        peg$c54 = /^[aA]/,
        peg$c55 = { type: "class", value: "[aA]", description: "[aA]" },
        peg$c56 = /^[nN]/,
        peg$c57 = { type: "class", value: "[nN]", description: "[nN]" },
        peg$c58 = /^[dD]/,
        peg$c59 = { type: "class", value: "[dD]", description: "[dD]" },
        peg$c60 = function(name, params) { return createFun(name.join("").toLowerCase(), params); },
        peg$c61 = /^[oO]/,
        peg$c62 = { type: "class", value: "[oO]", description: "[oO]" },
        peg$c63 = /^[rR]/,
        peg$c64 = { type: "class", value: "[rR]", description: "[rR]" },
        peg$c65 = function(name, params) { return createFun(name.join(""), params); },
        peg$c66 = "not",
        peg$c67 = { type: "literal", value: "not", description: "\"not\"" },
        peg$c68 = function(name, param) { return createFun(name, param); },
        peg$c69 = "isblank",
        peg$c70 = { type: "literal", value: "isblank", description: "\"isblank\"" },
        peg$c71 = null,
        peg$c72 = function(param) { return param; },
        peg$c73 = /^[ \t\r\n]/,
        peg$c74 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" },
        peg$c75 = ",",
        peg$c76 = { type: "literal", value: ",", description: "\",\"" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsecomparison();

      return s0;
    }

    function peg$parsecomparison() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesubadd();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseop_comparator();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsecomparison();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c1(s2, s4, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsesubadd();
      }

      return s0;
    }

    function peg$parsesubadd() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsemuldiv();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseop_subadd();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsesubadd();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c1(s2, s4, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsemuldiv();
      }

      return s0;
    }

    function peg$parsemuldiv() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseprimary();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseop_muldiv();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemuldiv();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c1(s2, s4, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseprimary();
      }

      return s0;
    }

    function peg$parseop_subadd() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c2.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c4(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseop_muldiv() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c5.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c7(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseop_comparator() {
      var s0;

      s0 = peg$parseop_comparator_le_ge();
      if (s0 === peg$FAILED) {
        s0 = peg$parseop_comparator_not_equal();
        if (s0 === peg$FAILED) {
          s0 = peg$parseop_comparator_single();
        }
      }

      return s0;
    }

    function peg$parseop_comparator_le_ge() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c8.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c10;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c12(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseop_comparator_not_equal() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c13) {
        s1 = peg$c13;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c15();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseop_comparator_single() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c16.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c17); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c18(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseprimary() {
      var s0;

      s0 = peg$parseinteger();
      if (s0 === peg$FAILED) {
        s0 = peg$parseblock();
        if (s0 === peg$FAILED) {
          s0 = peg$parseboolean();
          if (s0 === peg$FAILED) {
            s0 = peg$parsevariable();
            if (s0 === peg$FAILED) {
              s0 = peg$parsefunction();
              if (s0 === peg$FAILED) {
                s0 = peg$parsevariable2();
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseblock() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c19;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecomparison();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c21;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c22); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c23(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseboolean() {
      var s0;

      s0 = peg$parsetrue();
      if (s0 === peg$FAILED) {
        s0 = peg$parsefalse();
      }

      return s0;
    }

    function peg$parsetrue() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (peg$c24.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
        if (s3 !== peg$FAILED) {
          if (peg$c26.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c27); }
          }
          if (s4 !== peg$FAILED) {
            if (peg$c28.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c29); }
            }
            if (s5 !== peg$FAILED) {
              if (peg$c30.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c31); }
              }
              if (s6 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c32();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsefalse() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (peg$c33.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c34); }
        }
        if (s3 !== peg$FAILED) {
          if (peg$c35.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s4 !== peg$FAILED) {
            if (peg$c37.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c38); }
            }
            if (s5 !== peg$FAILED) {
              if (peg$c39.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c40); }
              }
              if (s6 !== peg$FAILED) {
                if (peg$c30.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c31); }
                }
                if (s7 !== peg$FAILED) {
                  s3 = [s3, s4, s5, s6, s7];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c0;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c41();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsevariable() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        if (peg$c43.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c44); }
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c44); }
            }
          }
        } else {
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$currPos;
          s6 = peg$parse_();
          if (s6 !== peg$FAILED) {
            if (peg$c46.test(input.charAt(peg$currPos))) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c47); }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$c0;
          }
          peg$silentFails--;
          if (s5 !== peg$FAILED) {
            peg$currPos = s4;
            s4 = peg$c45;
          } else {
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c48(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsevariable2() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c43.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c44); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c44); }
            }
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c49(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseinteger() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c51.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c51.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c52); }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c53(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }

      return s0;
    }

    function peg$parsefunction() {
      var s0;

      s0 = peg$parsefun_and();
      if (s0 === peg$FAILED) {
        s0 = peg$parsefun_or();
        if (s0 === peg$FAILED) {
          s0 = peg$parsefun_not();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefun_isblank();
          }
        }
      }

      return s0;
    }

    function peg$parsefun_and() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (peg$c54.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c55); }
        }
        if (s3 !== peg$FAILED) {
          if (peg$c56.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c57); }
          }
          if (s4 !== peg$FAILED) {
            if (peg$c58.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c59); }
            }
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c19;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parseparameter();
                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseparameter();
                  }
                } else {
                  s6 = peg$c0;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s8 = peg$c21;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c22); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c60(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsefun_or() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (peg$c61.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c62); }
        }
        if (s3 !== peg$FAILED) {
          if (peg$c63.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c64); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c19;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parseparameter();
                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseparameter();
                  }
                } else {
                  s6 = peg$c0;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s8 = peg$c21;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c22); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c65(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsefun_not() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c66) {
          s2 = peg$c66;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c67); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c19;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseparameter();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s8 = peg$c21;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c22); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c68(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsefun_isblank() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 7) === peg$c69) {
          s2 = peg$c69;
          peg$currPos += 7;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c70); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c19;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseparameter();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s8 = peg$c21;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c22); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c68(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseparameter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsecomma();
      if (s1 === peg$FAILED) {
        s1 = peg$c71;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecomparison();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c72(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsews() {
      var s0;

      if (peg$c73.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c74); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      s0 = [];
      s1 = peg$parsews();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsews();
      }

      return s0;
    }

    function peg$parsecomma() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c75;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c76); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }


      function create(type, left, right) {
        return {Type: type, Children: [left,right]};
      }

      function createOne(type, one) {
        return {Type: type, Children: [one]};
      }

      function createAtomic(type, val) {
        return {Type: type, Value: val};
      }


      function createVar(name) {
        return {Type: "variable", Name: name};
      }

      
      function createFun(name, params) {
        return {Type: "function", Name: name.toLowerCase(), Children: [params]};
      }



    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})()});angular.module('formulaParser', []).factory('FormulaParser',function(){ return (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = peg$FAILED,
        peg$c1 = /^[+\-]/,
        peg$c2 = { type: "class", value: "[+\\-]", description: "[+\\-]" },
        peg$c3 = function(left, sign, right) {
              if (sign === "+")
              { return create("add", left, right); }
              else
              { return create("sub", left, right); }
            },
        peg$c4 = function(left, operator, right) { return create(operator, left, right); },
        peg$c5 = /^[*\/]/,
        peg$c6 = { type: "class", value: "[*\\/]", description: "[*\\/]" },
        peg$c7 = function(sign) { if (sign === "*"){ return "mul"; } else { return "div"; } },
        peg$c8 = /^[<>]/,
        peg$c9 = { type: "class", value: "[<>]", description: "[<>]" },
        peg$c10 = "=",
        peg$c11 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c12 = function(double) { switch(double.join("")){
                                   case "<=": return "le";
                                   case ">=": return "ge";
                                 };
                               },
        peg$c13 = "<>",
        peg$c14 = { type: "literal", value: "<>", description: "\"<>\"" },
        peg$c15 = function() { return "ne"; },
        peg$c16 = /^[<=>]/,
        peg$c17 = { type: "class", value: "[<=>]", description: "[<=>]" },
        peg$c18 = function(single) { return single; },
        peg$c19 = "and",
        peg$c20 = { type: "literal", value: "and", description: "\"and\"" },
        peg$c21 = function() { return "and"; },
        peg$c22 = "or",
        peg$c23 = { type: "literal", value: "or", description: "\"or\"" },
        peg$c24 = function() { return "or"; },
        peg$c25 = "(",
        peg$c26 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c27 = ")",
        peg$c28 = { type: "literal", value: ")", description: "\")\"" },
        peg$c29 = function(block) { return createOne("block", block); },
        peg$c30 = "$",
        peg$c31 = { type: "literal", value: "$", description: "\"$\"" },
        peg$c32 = /^[a-zA-Z]/,
        peg$c33 = { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
        peg$c34 = [],
        peg$c35 = /^[a-zA-Z0-9]/,
        peg$c36 = { type: "class", value: "[a-zA-Z0-9]", description: "[a-zA-Z0-9]" },
        peg$c37 = ":",
        peg$c38 = { type: "literal", value: ":", description: "\":\"" },
        peg$c39 = /^[a-zA-Z0-9_]/,
        peg$c40 = { type: "class", value: "[a-zA-Z0-9_]", description: "[a-zA-Z0-9_]" },
        peg$c41 = function(name) { return createVar(name[1] + name[2].join("") + name[3] + name[4].join("")); },
        peg$c42 = { type: "other", description: "integer" },
        peg$c43 = /^[0-9.]/,
        peg$c44 = { type: "class", value: "[0-9.]", description: "[0-9.]" },
        peg$c45 = function(digits) { return createAtomic(parseFloat(digits.join(""), 10)); },
        peg$c46 = "exists",
        peg$c47 = { type: "literal", value: "exists", description: "\"exists\"" },
        peg$c48 = function(param) { return createFun("exists", param); },
        peg$c49 = null,
        peg$c50 = function(param) { return param; },
        peg$c51 = /^[ \t\r\n]/,
        peg$c52 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" },
        peg$c53 = ",",
        peg$c54 = { type: "literal", value: ",", description: "\",\"" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsesubadd();

      return s0;
    }

    function peg$parsesubadd() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsemuldivcomplog();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (peg$c1.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c2); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsesubadd();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c3(s2, s4, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsemuldivcomplog();
      }

      return s0;
    }

    function peg$parsemuldivcomplog() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseprimary();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseop_muldiv();
            if (s4 === peg$FAILED) {
              s4 = peg$parseop_comparator();
              if (s4 === peg$FAILED) {
                s4 = peg$parseop_logical();
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemuldivcomplog();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c4(s2, s4, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseprimary();
      }

      return s0;
    }

    function peg$parseop_muldiv() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c5.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c7(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseop_comparator() {
      var s0;

      s0 = peg$parseop_comparator_le_ge();
      if (s0 === peg$FAILED) {
        s0 = peg$parseop_comparator_not_equal();
        if (s0 === peg$FAILED) {
          s0 = peg$parseop_comparator_single();
        }
      }

      return s0;
    }

    function peg$parseop_comparator_le_ge() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c8.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c10;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c12(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseop_comparator_not_equal() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c13) {
        s1 = peg$c13;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c15();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseop_comparator_single() {
      var s0, s1;

      s0 = peg$currPos;
      if (peg$c16.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c17); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c18(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseop_logical() {
      var s0;

      s0 = peg$parseop_log_and();
      if (s0 === peg$FAILED) {
        s0 = peg$parseop_log_or();
      }

      return s0;
    }

    function peg$parseop_log_and() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c19) {
        s1 = peg$c19;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c21();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseop_log_or() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c22) {
        s1 = peg$c22;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c23); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c24();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseprimary() {
      var s0;

      s0 = peg$parseinteger();
      if (s0 === peg$FAILED) {
        s0 = peg$parseblock();
        if (s0 === peg$FAILED) {
          s0 = peg$parsevariable();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefun_exists();
          }
        }
      }

      return s0;
    }

    function peg$parseblock() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c25;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c26); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesubadd();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c27;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c28); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c29(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsevariable() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 36) {
          s3 = peg$c30;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c31); }
        }
        if (s3 !== peg$FAILED) {
          if (peg$c32.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c33); }
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$c35.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c36); }
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              if (peg$c35.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c36); }
              }
            }
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s6 = peg$c37;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                if (peg$c39.test(input.charAt(peg$currPos))) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c40); }
                }
                if (s8 !== peg$FAILED) {
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    if (peg$c39.test(input.charAt(peg$currPos))) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c40); }
                    }
                  }
                } else {
                  s7 = peg$c0;
                }
                if (s7 !== peg$FAILED) {
                  s3 = [s3, s4, s5, s6, s7];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c0;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c41(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseinteger() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      if (peg$c43.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c44); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c43.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c44); }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c45(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }

      return s0;
    }

    function peg$parsefun_exists() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c46) {
          s2 = peg$c46;
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c47); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c25;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c26); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseparameter();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s8 = peg$c27;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c28); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c48(s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseparameter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsecomma();
      if (s1 === peg$FAILED) {
        s1 = peg$c49;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesubadd();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c50(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsews() {
      var s0;

      if (peg$c51.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      s0 = [];
      s1 = peg$parsews();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsews();
      }

      return s0;
    }

    function peg$parsecomma() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c53;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c54); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }


      function create(type, left, right) {
        return {Type: type, Children: [left,right]};
      }

      function createOne(type, one) {
        return {Type: type, Children: [one]};
      }

      function createAtomic(val) {
        return {Type: "atomic", Value: val};
      }


      function createVar(name) {
        return {Type: "variable", ConceptName: name};
      }


      function createFun(name, params) {
        return {Type: "function", Name: name, Params: [params]};
      }



    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})()});'use strict';

angular.module('formulaEditor',['excelParser', 'formulaParser'])
.factory('Formula', ['$q', '$log', 'ExcelParser', 'FormulaParser', function($q, $log, ExcelParser, FormulaParser){

    var ensureParameter = function(paramValue, paramName, paramType, functionName, regex, regexErrorMessage) {
        if(paramValue === null || paramValue === undefined) {
            throw new Error(functionName + ': function called without mandatory "' + paramName + '" parameter.');
        }
        if(typeof paramValue !== paramType) {
            throw new Error(functionName + ': function called with mandatory "' + paramName + '" parameter which is of wrong type "' + typeof paramValue + '" (should be of type "' + paramType + '" instead).');
        }
        if(regex !== undefined && paramValue.match(regex) === null) {
            throw new Error(functionName + ': ' + regexErrorMessage);
        }
    };

    //Constructor
    var Formula = function(modelOrRuleType, report, computableConcept, language){
        if(typeof modelOrRuleType === 'object' && modelOrRuleType !== null){
            this.report = report;
            this.setModel(modelOrRuleType);
        } else {
            ensureParameter(modelOrRuleType, 'modelOrRuleType', 'string', 'Formula (Const.)',/^(xbrl28:formula)|(xbrl28:validation)$/g,'unknown rule type: ' + modelOrRuleType);
            ensureParameter(computableConcept, 'computableConcept', 'string', 'Formula (Const.)');
            ensureParameter(language, 'language', 'string', 'Formula (Const.)');
            ensureParameter(report, 'report', 'object', 'Formula (Const.)');
            this.report = report;
            this.parser = null;
            if (modelOrRuleType === 'xbrl28:validation'){
                this.setModel({
                    'Id': report.uuid(),
                    'Type': modelOrRuleType,
                    'Label': '',
                    'Description': '',
                    'ComputableConcepts': [ computableConcept + 'Validation' ],
                    'ValidatedConcepts': [ computableConcept ],
                    'DependsOn': [],
                    'Formula': ''
                });
            } else if (modelOrRuleType === 'xbrl28:formula') {
                if(language === 'SpreadsheetFormula') {
                    this.setModel({
                        'Id': report.uuid(),
                        'Type': modelOrRuleType,
                        'OriginalLanguage': language,
                        'Label': '',
                        'Description': '',
                        'ComputableConcepts': [ computableConcept ],
                        'DependsOn': [],
                        'AllowCrossPeriod': true,
                        'AllowCrossBalance': true,
                        'Formulae': [
                            {
                                'PrereqSrc': 'TRUE',
                                'Prereq': {},
                                'SourceFact': [],
                                'BodySrc': '',
                                'Body': {},
                                'active': true
                            }
                        ]
                    });
                } else {
                    this.setModel({
                        'Id': report.uuid(),
                        'Type': modelOrRuleType,
                        'Label': '',
                        'Description': '',
                        'ComputableConcepts': [ computableConcept ],
                        'DependsOn': [],
                        'Formula': ''
                    });
                }
            }
        }
    };

    Formula.prototype.addAlternative = function(){
        if(this.model.Formulae === undefined || this.model.Formulae === null){
            this.model.Formulae = [];
        }
        var language = this.model.OriginalLanguage;
        if(language === 'SpreadsheetFormula') {
            this.model.Formulae.push(
                {
                    'PrereqSrc': 'TRUE',
                    'Prereq': {},
                    'SourceFact': [],
                    'BodySrc': '',
                    'Body': {},
                    'active': true
                });
        }
    };

    Formula.prototype.copyAlternative = function(index){
        var formulae = this.model.Formulae;
        if(formulae === undefined || formulae === null || index >= formulae.length){
            throw new Error('Index out of bounds: ' + index + '. Array: ' + JSON.stringify(formulae));
        }
        var alternative = angular.copy(formulae[index]);
        var language = this.model.OriginalLanguage;
        if(language === 'SpreadsheetFormula') {
            formulae.push( alternative);
            alternative.active = true;
        }
    };

    Formula.prototype.removeAlternative = function(index){
        var formulae = this.model.Formulae;
        if(formulae === undefined || formulae === null || index >= formulae.length){
            throw new Error('Index out of bounds: ' + index + '. Array: ' + JSON.stringify(formulae));
        }
        formulae.splice(index, 1);
    };

    Formula.prototype.getPrefix = function(){
        var prefix;
        if(this.report !== undefined && this.report !== null && typeof this.report === 'object'){
            prefix = this.report.getPrefix();
        }
        if(this.report === undefined || prefix === undefined || prefix === null || prefix === ''){
            return 'ext';
        }
        return prefix;
    };

    Formula.prototype.getParser = function() {
        if(this.parser === undefined || this.parser === null ) {
            if(this.model.OriginalLanguage === 'ArithmeticFormula') {
                this.parser = FormulaParser;
                this.parserType = 'FormulaParser';
            }
            if(this.model.OriginalLanguage === 'SpreadsheetFormula') {
                this.parser = ExcelParser;
                this.parserType = 'ExcelParser';
            }
        }
        return this.parser;
    };

    /*Formula.prototype.updateView = function() {
        this.view = JSON.stringify(this.model, null, ' ');
    };*/

    var alignConceptPrefix = function(prefix, concept){
        var result;
        if(concept !== undefined && concept !== null && typeof concept === 'string') {
            if (concept.indexOf(':') === -1) {
                result = prefix + ':' + concept;
            } else {
                result = concept;
            }
        }
        return result;
    };

    var alignConceptPrefixes = function(prefix, conceptsArray){
        var result = [];
        if(conceptsArray !== undefined && conceptsArray !== null && typeof conceptsArray === 'object') {
            for (var i in conceptsArray) {
                var concept = conceptsArray[i];
                result.push(alignConceptPrefix(prefix, concept));
            }
        }
        return result;
    };

    var makeUnique = function(array){
        ensureParameter(array, 'array', 'object', 'makeUnique');
        var unique = {}, result = [];
        for(var j in array){
            var item = array[j];
            if(unique.hasOwnProperty(item)) {
                continue;
            }
            result.push(item);
            unique[item] = 1;
        }
        return result;
    };

    var inferDependenciesImpl = function(formula, obj){
        ensureParameter(formula, 'formula', 'object', 'inferDependenciesImpl');
        ensureParameter(obj, 'obj', 'object', 'inferDependenciesImpl');
        var prefix = formula.getPrefix();
        var result = [];
        var formulae = obj.Formulae;
        if(formulae !== undefined && formulae !== null && typeof formulae === 'object'){
            for(var i in formulae){
                var alternative = formulae[i];
                result = result.concat(inferDependenciesImpl(formula, alternative));
            }
            result = alignConceptPrefixes(prefix, result);
            result = makeUnique(result);
            obj.DependsOn = result;
        } else {
            var prereq = obj.Prereq;
            var body = obj.Body;
            var sourceFacts = obj.SourceFact;
            if (prereq !== undefined || body !== undefined || sourceFacts !== undefined) {
                if (prereq !== undefined && prereq !== null && typeof prereq === 'object') {
                    result = result.concat(inferDependenciesImpl(formula, prereq));
                }
                if (body !== undefined && body !== null && typeof body === 'object') {
                    result = result.concat(inferDependenciesImpl(formula, body));
                }
                if (sourceFacts !== undefined && sourceFacts !== null && typeof sourceFacts === 'object') {
                    result = result.concat(sourceFacts);
                }
            } else {
                var type = obj.Type;
                var children = obj.Children;
                if(type === 'variable'){
                    var name = obj.Name;
                    result.push(name);
                } else if(children !== undefined && children !== null && typeof children === 'object'){
                    for(var j in children){
                        var child = children[j];
                        result = result.concat(inferDependenciesImpl(formula, child));
                    }
                }
            }
        }
        return result;
    };

    var inferDependencies = function(formula, obj, async) {
        ensureParameter(formula, 'formula', 'object', 'inferDependencies');
        ensureParameter(obj, 'obj', 'object', 'inferDependencies');
        if(async === undefined || async === null || async) {
            var deferred = $q.defer();
            var result = inferDependenciesImpl(formula, obj);
            deferred.resolve(result);
            return deferred.promise;
        } else {
            return inferDependenciesImpl(formula, obj);
        }
    };

    // computation is the jsoniq code part that computes the value of the new
    // fact
    var toComputation = function(ast){
        if(ast !== undefined && ast !== null && typeof ast === 'object'){
            var type = ast.Type;
            var children = ast.Children;
            var value = ast.Value;
            var name = ast.Name;
            switch(type){
                // comparisons
                case 'eq':
                case 'ne':
                case 'gt':
                case 'ge':
                case 'lt':
                case 'le': return toComputation(children[0]) + ' ' + type + ' ' + toComputation(children[1]);

                // arithmetics
                case 'add': return toComputation(children[0]) + ' + ' + toComputation(children[1]);
                case 'mul': return toComputation(children[0]) + ' * ' + toComputation(children[1]);
                case 'div': return toComputation(children[0]) + ' div ' + toComputation(children[1]);
                case 'sub': return toComputation(children[0]) + ' - ' + toComputation(children[1]);

                // primaries
                case 'block':
                    var inner = [];
                    for(var i in children) {
                        var child = children[i];
                        inner.push(toComputation(child));
                    }
                    return '(' + inner.join(',') + ')';
                case 'variable': return 'rules:decimal-value($' + name + ')';

                // atomics
                case 'numeric': return value;
                case 'boolean': return value;
                case 'string': return '\"' + value + '\"';

                // functions
                case 'function':
                    var innerparams = [];
                    for(var j in children) {
                        var param = children[j];
                        innerparams.push(toComputation(param));
                    }
                    switch(name){
                        case 'isblank':
                            var innerparams2 = [];
                            for(var h in children) {
                                if(children.hasOwnProperty(h)) {
                                    var p = children[j];
                                    if(p.Type === 'variable'){
                                        innerparams2.push('$' + p.Name);
                                    } else {
                                        innerparams2.push(toComputation(p));
                                    }
                                }
                            }
                            return 'not(exists(' + innerparams2.join(', ') + '))';
                        case 'not': return 'not((' + innerparams.join(', ') + '))';
                        case 'and': return '(' + innerparams.join(' and ') + ')';
                        case 'or': return '(' + innerparams.join(' or ') + ')';
                    }
            }
        }
    };

    // computation is the jsoniq code part that creates the audit trail of the new
    // fact
    var toAuditTrail = function(ast){
        if(ast !== undefined && ast !== null && typeof ast === 'object'){
            var type = ast.Type;
            var children = ast.Children;
            var value = ast.Value;
            var name = ast.Name;
            var result = [];
            switch(type){
                // comparisons
                case 'eq':
                case 'ne':
                case 'gt':
                case 'ge':
                case 'lt':
                case 'le': result.push(toAuditTrail(children[0]) + ' || " ' + type + ' " || ' + toAuditTrail(children[1])); break;

                // arithmetics
                case 'add': result.push(toAuditTrail(children[0]) + ' || " + " || ' + toAuditTrail(children[1])); break;
                case 'mul': result.push(toAuditTrail(children[0]) + ' || " * " || ' + toAuditTrail(children[1])); break;
                case 'div': result.push(toAuditTrail(children[0]) + ' || " div " || ' + toAuditTrail(children[1])); break;
                case 'sub': result.push(toAuditTrail(children[0]) + ' || " - " || ' + toAuditTrail(children[1])); break;

                // primaries
                case 'block':
                    var inner = [];
                    for(var i in children) {
                        var child = children[i];
                        inner.push(toAuditTrail(child));
                    }
                    result.push('" ( " || ' + inner.join(' || ", "') + ' || " )"');
                    break;
                case 'variable': result.push('rules:fact-trail($' + name + ', "' + name + '")'); break;

                // atomics
                case 'numeric':
                case 'boolean':
                case 'string': result.push('"' + value + '"');  break;

                // functions
                case 'function':
                    var innerparams = [];
                    for(var j in children) {
                        var param = children[j];
                        innerparams.push(toAuditTrail(param));
                    }
                    switch(name){
                        case 'isblank': result.push('"not(exists( " || ' + innerparams.join(' || ", "') + ' || "))"'); break;
                        case 'not': result.push('not((' + innerparams.join(' || ", "') + ' || "))"'); break;
                        case 'and': result.push('(' + innerparams.join(' || " and "') + ' || ")"'); break;
                        case 'or': result.push('(' + innerparams.join(' || " or "') + ' || ")"'); break;
                    }
                    break;
            }
            return result.join(' || ');
        }
    };

    var getUniqueFacts = function(report, prefix){
        var facts = [];
        facts = facts.concat(report.model.ComputableConcepts);
        facts = facts.concat(report.model.DependsOn);
        if((report.model.OriginalLanguage === 'SpreadsheetFormula') &&
            report.model.Formulae !== undefined && report.model.Formulae !== null) {
            for (var i in report.model.Formulae) {
                facts = facts.concat(report.model.Formulae[i].SourceFact);
            }
        }
        return makeUnique(alignConceptPrefixes(prefix, facts));
    };

    Formula.prototype.toJsoniq = function() {
        var result = [];
        var prefix = this.getPrefix();
        var computedConcept = alignConceptPrefix(prefix, this.model.ComputableConcepts[0]);
        if(this.model !== undefined && this.model !== null && typeof this.model ==='object') {
            if ((this.model.OriginalLanguage === 'SpreadsheetFormula') &&
                this.model.Formulae !== undefined && this.model.Formulae !== null) {

                var facts = getUniqueFacts(this, prefix);
                var computedFactVariable;
                if(computedConcept.indexOf( prefix + ':') === 0){
                    computedFactVariable = computedConcept.substring(prefix.length + 1);
                }else{
                    computedFactVariable = computedConcept.replace(/:/g, '_');
                }
                var allowCrossPeriod = this.model.AllowCrossPeriod;
                var allowCrossBalance = this.model.AllowCrossBalance;
                var factsFilter = '';
                for(var i in facts){
                    var fact = facts[i];
                    if(factsFilter === ''){
                        factsFilter = '"';
                    }else{
                        factsFilter += ', "';
                    }
                    factsFilter += fact + '"';
                }
                var variables = [];
                for(var j in facts){
                    var concept = facts[j];
                    var variable = {};
                    if(concept.indexOf( prefix + ':') === 0){
                        variable.Name = concept.substring(prefix.length + 1);
                    }else{
                        variable.Name = concept.replace(/:/g, '_');
                    }
                    variable.Concept = alignConceptPrefix(prefix, concept);
                    variables.push(variable);
                }
                var auditTrailSourceFacts = '';
                for(var y in variables){
                    if(variables.hasOwnProperty(y)) {
                        var va = variables[y];
                        if(auditTrailSourceFacts===''){
                            auditTrailSourceFacts += '$';
                        } else {
                            auditTrailSourceFacts += ', $';
                        }
                        auditTrailSourceFacts += va.Name;
                    }
                }

                result.push('');
                result.push('for $facts in facts:facts-for-internal((');
                result.push('      ' + factsFilter);
                result.push('    ), $hypercube, $aligned-filter, $concept-maps, $rules, $cache, $options)');
                if (allowCrossPeriod) {
                    result.push('let $aligned-period := ( facts:duration-for-fact($facts).End, facts:instant-for-fact($facts), "forever")[1]');
                }
                result.push('group by $canonical-filter-string := ');
                if (allowCrossBalance) {
                    result.push('  facts:canonically-serialize-object($facts, ($facts:CONCEPT, "_id", "IsInDefaultHypercube", "Type", "Value", "Decimals", "AuditTrails", "xbrl28:Type", "Balance"))');
                } else {
                    result.push('  facts:canonically-serialize-object($facts, ($facts:CONCEPT, "_id", "IsInDefaultHypercube", "Type", "Value", "Decimals", "AuditTrails", "xbrl28:Type"))');
                }
                if (allowCrossPeriod) {
                    result.push('  , $aligned-period');
                }
                for(var x in variables){
                    if(variables.hasOwnProperty(x)) {
                        var v = variables[x];
                        result.push('let $' + v.Name + ' as object? := $facts[$$.$facts:ASPECTS.$facts:CONCEPT eq "' + v.Concept + '"]');
                    }
                }
                result.push('let $_unit := ($facts.$facts:ASPECTS.$facts:UNIT)[1]');
                result.push('return');
                result.push('  switch (true)');
                result.push('  case exists($' + computedFactVariable + ') return $' + computedFactVariable);

                for (var k in this.model.Formulae) {
                    if(this.model.Formulae.hasOwnProperty(k)) {
                        var alternative = this.model.Formulae[k];
                        var body = alternative.Body;
                        var prereq = alternative.Prereq;
                        var sourceFacts = alignConceptPrefixes(prefix, alternative.SourceFact);
                        var sourceFactVariable;
                        if(sourceFacts[0] !== undefined && sourceFacts[0].indexOf( prefix + ':') === 0){
                            sourceFactVariable = sourceFacts[0].substring(prefix.length + 1);
                        } else if(sourceFacts[0] !== undefined) {
                            sourceFactVariable = sourceFacts[0].replace(/:/g, '_');
                        }
                        var sourceFactExistenceCheck = '';
                        for(var s in sourceFacts){
                            if(sourceFacts.hasOwnProperty(s)){
                                var sFact = sourceFacts[s];
                                if(sFact.indexOf( prefix + ':') === 0){
                                    sFact = sFact.substring(prefix.length + 1);
                                }else{
                                    sFact = sFact.replace(/:/g, '_');
                                }
                                if(sourceFactExistenceCheck !== ''){
                                    sourceFactExistenceCheck += ' and ';
                                }
                                sourceFactExistenceCheck += 'exists($' + sFact + ')';
                            }
                        }

                        result.push('  case (' + sourceFactExistenceCheck + ' and ' + toComputation(prereq) + ')');
                        result.push('  return');
                        result.push('    let $computed-value := ' + toComputation(body));
                        result.push('    let $audit-trail-message := ');
                        result.push('	     rules:fact-trail({"Aspects": { "xbrl:Unit" : $_unit, "xbrl:Concept" : "' + computedConcept + '" }, Value: $computed-value }) || " = "');
                        result.push('	        || ' + toAuditTrail(body));
                        result.push('	 let $source-facts := (' + auditTrailSourceFacts + ')');
                        result.push('    return');
                        result.push('      rules:create-computed-fact(');
                        result.push('          $' + sourceFactVariable + ',');
                        result.push('          "' + computedConcept + '",');
                        result.push('          $computed-value,');
                        result.push('          $rule,');
                        result.push('          $audit-trail-message,');
                        result.push('          $source-facts,');
                        result.push('          $options)');

                    }
                }
                result.push('  default return ()');

            }
        }
        return result.join('\n');
    };

    Formula.prototype.compile = function() {
        if((this.model.OriginalLanguage === 'SpreadsheetFormula') &&
            this.model.Formulae !== undefined && this.model.Formulae !== null) {
            $log.log('starting compilation');
            for (var i = 0; i < this.model.Formulae.length; ++i) {
                this.compilePrereq(i, false /* not deferred */);
                this.compileBody(i, false /* not deferred */);
            }
            inferDependencies(this, this.model, false /* not deferred */);
            this.model.Formula = this.toJsoniq();
            $log.log('compilation finished');
        }
    };

    var bodyEmptyErrorMessage = 'Rule code section cannot be empty. Example code: "((NetIncomeLoss/Revenues)*(1+(Assets-Equity)/Equity))/((1/(Revenues/Assets))-((NetIncomeLoss/Revenues)*(1+(Assets-Equity)/Equity)))"';

    Formula.prototype.compileBodyDeferred = function(index) {
        ensureParameter(index, 'index', 'number', 'compileBodyDeferred');
        var deferred = $q.defer();
        var parser = this.getParser();
        var altComp = this.model.Formulae[index];
        var body;
        if(altComp.BodySrc === undefined || altComp.BodySrc === '' || altComp.BodySrc === null){
            deferred.reject(bodyEmptyErrorMessage);
        }else {
            try {
                body = parser.parse(altComp.BodySrc);
                deferred.resolve(body);
            }
            catch (e) {
                var errMsg = this.parserType + ' ' + e.name + ' Error: (' + e.line + ',' + e.column + ') ' + e.message;
                deferred.reject(errMsg);
            }
        }
        return deferred.promise;
    };

    Formula.prototype.compileBody = function(index, async, action) {
        ensureParameter(index, 'index', 'number', 'compileBody');
        var that = this;
        var altComp = that.model.Formulae[index];
        var successFunc = function (body) {
            altComp.Body = body;
            if (altComp.BodyErr !== undefined) {
                delete altComp.BodyErr;
            }
            //$log.log(that.parserType + ' Body ok');
            that.model.Formulae[index] = altComp;
            if(async !== false){
                inferDependencies(that, that.model, async).then(
                    function() {
                        that.validate(action);
                    });
            } else {
                that.validate(action);
            }
        };
        var errorFunc = function (errMsg) {
            altComp.BodyErr = errMsg;
            altComp.Body = {};
            $log.log(errMsg);
            that.model.Formulae[index] = altComp;
            that.validate(action);
        };
        if(async === undefined || async === null || async === true) {
            this.compileBodyDeferred(index).then(successFunc, errorFunc);
        } else {
            var parser = this.getParser();
            var body;
            if(altComp.BodySrc === undefined || altComp.BodySrc === '' || altComp.BodySrc === null){
                errorFunc(bodyEmptyErrorMessage);
            }else {
                try {
                    body = parser.parse(altComp.BodySrc);
                    successFunc(body);
                }
                catch (e) {
                    var errMsg = this.parserType + ' ' + e.name + ' Error: (' + e.line + ',' + e.column + ') ' + e.message;
                    errorFunc(errMsg);
                }
            }
        }
    };

    var prereqEmptyErrorMessage = 'Rule precondition section cannot be empty. If you don\'t want to check a precondition just put "TRUE".';

    Formula.prototype.compilePrereqDeferred = function(index) {
        ensureParameter(index, 'index', 'number', 'compilePrereqDeferred');
        var deferred = $q.defer();
        var parser = this.getParser();
        var altComp = this.model.Formulae[index];
        var prereq;
        if(altComp.PrereqSrc === undefined || altComp.PrereqSrc === '' || altComp.PrereqSrc === null){
            deferred.reject(prereqEmptyErrorMessage);
        }else {
            try {
                prereq = parser.parse(altComp.PrereqSrc);
                deferred.resolve(prereq);
            }
            catch (e) {
                var errMsg = this.parserType + ' ' + e.name + ' Error: (' + e.line + ',' + e.column + ') ' + e.message;
                deferred.reject(errMsg);
            }
        }
        return deferred.promise;
    };

    Formula.prototype.compilePrereq = function(index, async, action) {
        ensureParameter(index, 'index', 'number', 'compilePrereq');
        var that = this;
        var altComp = that.model.Formulae[index];
        var successFunc = function(prereq){
            altComp.Prereq = prereq;
            if(altComp.PrereqErr !== undefined){
                delete altComp.PrereqErr;
            }
            //$log.log(that.parserType + ' Prereq ok');
            that.model.Formulae[index] = altComp;
            if(async !== false){
                inferDependencies(that, that.model, async).then(
                    function() {
                        that.validate(action);
                    });
            } else {
                that.validate(action);
            }
        };
        var errorFunc = function(errMsg){
            var altComp = that.model.Formulae[index];
            altComp.PrereqErr = errMsg;
            altComp.Prereq = {};
            $log.log(errMsg);
            that.model.Formulae[index] = altComp;
            that.validate(action);
        };
        if(async === undefined || async === null || async === true) {
            this.compilePrereqDeferred(index).then(successFunc, errorFunc);
        } else {
            var parser = this.getParser();
            var prereq;
            if(altComp.PrereqSrc === undefined || altComp.PrereqSrc === '' || altComp.PrereqSrc === null){
                errorFunc(prereqEmptyErrorMessage);
            }else {
                try {
                    prereq = parser.parse(altComp.PrereqSrc);
                    successFunc(prereq);
                }
                catch (e) {
                    var errMsg = this.parserType + ' ' + e.name + ' Error: (' + e.line + ',' + e.column + ') ' + e.message;
                    errorFunc(errMsg);
                }
            }
        }
    };

    var validateId = function(rule, report, action){
        var existingRule;
        var id = rule.Id;
        if(id === undefined || id === null || id === ''){
            rule.IdErr = 'Rule Id is mandatory.';
            rule.valid = false;
        } else if(action === 'Create' && (existingRule = report.getRule(id)) !== undefined && existingRule !== null) {
            rule.IdErr = 'A rule with id "' + id + '" does already exist.';
            rule.valid = false;
        } else {
            delete rule.IdErr;
        }
    };

    var validateLabel = function(rule){
        var label = rule.Label;
        if(label === undefined || label === null || label === ''){
            rule.LabelErr = 'Rule Label is mandatory.';
            rule.valid = false;
        } else {
            delete rule.LabelErr;
        }
    };

    var validateComputableConcepts = function(rule, report, prefix){
        var computableConcepts = rule.ComputableConcepts;
        if(computableConcepts[0] === '' || computableConcepts.length === 0){
            rule.ComputableConceptsErr = 'Computable Concept is mandatory.';
            rule.valid = false;
        } else {
            var notExistingConcepts = [];
            for (var i in computableConcepts){
                if(computableConcepts.hasOwnProperty(i)) {
                    var concept = report.getConcept(alignConceptPrefix(prefix, computableConcepts[i]));
                    if (concept === undefined || concept === null) {
                        notExistingConcepts.push(computableConcepts[i]);
                    }
                }
            }
            if(notExistingConcepts.length === 1) {
                rule.ComputableConceptsErr = 'The computed concept "' + notExistingConcepts[0] + '" does not exist.';
                rule.valid = false;
            } else if(notExistingConcepts.length > 1) {
                rule.ComputableConceptsErr = 'The following concepts do not exist: "' + notExistingConcepts.join('", "') + '".';
                rule.valid = false;
            }else {
                delete rule.ComputableConceptsErr;
            }
        }
    };

    var validateDependsOnConcepts = function(rule, report, prefix){
        var dependsOnConcepts = rule.DependsOn;
        var notExistingConcepts = [];
        for (var i in dependsOnConcepts){
            if(dependsOnConcepts.hasOwnProperty(i)) {
                var concept = report.getConcept(alignConceptPrefix(prefix, dependsOnConcepts[i]));
                if (concept === undefined || concept === null) {
                    notExistingConcepts.push(dependsOnConcepts[i]);
                }
            }
        }
        if(notExistingConcepts.length === 1) {
            rule.DependsOnErr = 'The depending concept "' + notExistingConcepts[0] + '" does not exist.';
            rule.valid = false;
        } else if(notExistingConcepts.length > 1) {
            rule.DependsOnErr = 'The following depending concepts do not exist: "' + notExistingConcepts.join('", "') + '".';
            rule.valid = false;
        }else {
            delete rule.DependsOnErr;
        }
    };

    var validateValidatedConcepts = function(rule, report, prefix){
        var validatedConcepts = rule.ValidatedConcepts;
        if(validatedConcepts[0] === '' || validatedConcepts.length === 0){
            rule.ValidatedConceptsErr = 'Validated Concept is mandatory.';
            rule.valid = false;
        } else {
            var notExistingConcepts = [];
            for (var i in validatedConcepts){
                if(validatedConcepts.hasOwnProperty(i)) {
                    var concept = report.getConcept(alignConceptPrefix(prefix, validatedConcepts[i]));
                    if (concept === undefined || concept === null) {
                        notExistingConcepts.push(validatedConcepts[i]);
                    }
                }
            }
            if(notExistingConcepts.length === 1) {
                rule.ValidatedConceptsErr = 'The validated concept "' + notExistingConcepts[0] + '" does not exist.';
                rule.valid = false;
            } else if(notExistingConcepts.length > 1) {
                rule.ValidatedConceptsErr = 'The following validated concepts do not exist: "' + notExistingConcepts.join('", "') + '".';
                rule.valid = false;
            }else {
                delete rule.ValidatedConceptsErr;
            }
        }
    };

    var validateFormula = function(rule){
        var formula = rule.Formula;
        if(formula === undefined || formula === null || formula === ''){
            rule.FormulaErr = 'Rule Code Section is mandatory.';
            rule.valid = false;
        } else {
            delete rule.FormulaErr;
        }
    };

    var validateAlternative = function(rule, alternative, report, prefix){
        var sourceFact = alternative.SourceFact;
        if(sourceFact === undefined || sourceFact === null || sourceFact[0] === '' || sourceFact.length === 0){
            alternative.SourceFactErr = 'Source Fact is mandatory (general characteristics - e.g. credit or debit - will be copied from this fact).';
            alternative.valid = false;
        } else {
            var notExistingConcepts = [];
            // multiple source facts are not supported, this is for future compatibility
            for (var i in sourceFact){
                if(sourceFact.hasOwnProperty(i)) {
                    var concept = report.getConcept(alignConceptPrefix(prefix, sourceFact[i]));
                    if (concept === undefined || concept === null) {
                        notExistingConcepts.push(sourceFact[i]);
                    }
                }
            }
            if(notExistingConcepts.length === 1) {
                alternative.SourceFactErr = 'The source concept "' + notExistingConcepts[0] + '" does not exist.';
                alternative.valid = false;
            } else if(notExistingConcepts.length > 1) {
                alternative.SourceFactErr = 'The following source concepts do not exist: "' + notExistingConcepts.join('", "') + '".';
                alternative.valid = false;
            }else {
                delete alternative.SourceFactErr;
            }
            if(alternative.SourceFactErr === undefined && alternative.BodyErr === undefined && alternative.PrereqErr === undefined){
                alternative.valid = true;
            } else {
                alternative.valid = false;
            }
        }
    };

    var validateAlternatives = function(rule, report, prefix){
        var formulae = rule.Formulae;
        if(formulae === undefined || formulae === null || formulae[0] === '' || formulae.length === 0){
            rule.FormulaeErr = 'At least one alternative code section is mandatory.';
            rule.valid = false;
        } else {
            for (var i in formulae){
                if(formulae.hasOwnProperty(i)) {
                    var alternative = formulae[i];
                    validateAlternative(rule, alternative, report, prefix);
                    if (!alternative.valid) {
                        rule.valid = false;
                    }
                }
            }
        }
    };

    Formula.prototype.validate = function (action) {
        var report = this.report;
        var rule = this.getModel();

        if(rule !== undefined && rule !== null && typeof rule === 'object') {
            var prefix = this.getPrefix();
            var type = rule.Type;
            rule.valid = true;
            validateId(rule, report, action);
            validateLabel(rule);
            validateComputableConcepts(rule, report, prefix);
            validateDependsOnConcepts(rule, report, prefix);
            if(type === 'xbrl28:validation' ){
                validateValidatedConcepts(rule, report, prefix);
            }
            validateFormula(rule);
            if(rule.OriginalLanguage === 'SpreadsheetFormula' ){
                validateAlternatives(rule, report, prefix);
            }
            return rule.valid;
        }
    };

    Formula.prototype.isValid = function(){
        if(this.model === undefined || this.model === null || typeof this.model !== 'object'){
            return false;
        }
        if(this.model.valid === undefined){
            return false;
        }else {
            return this.model.valid;
        }
    };

    Formula.prototype.getRule = function () {
        var model = this.getModel();
        if(model.OriginalLanguage === 'SpreadsheetFormula') {
            this.compile();
        }
        var computableConcepts = alignConceptPrefixes(this.getPrefix(), model.ComputableConcepts);
        var rule = {
            'Id': model.Id,
            'OriginalLanguage': model.OriginalLanguage,
            'Type': model.Type,
            'Label': model.Label,
            'Description': model.Description,
            'ComputableConcepts': computableConcepts,
            'DependsOn': model.DependsOn,
            'Formula': model.Formula
        };
        if(model.ValidatedConcepts !== undefined){
            rule.ValidatedConcepts = alignConceptPrefixes(this.getPrefix(), model.ValidatedConcepts);
        }
        if(model.Formulae !== undefined && model.Formulae !== null && typeof model.Formulae === 'object') {
            rule.Formulae = model.Formulae;
        }
        rule.AllowCrossPeriod = model.AllowCrossPeriod;
        rule.AllowCrossBalance = model.AllowCrossBalance;
        //$log.log('getRule done');
        return rule;
    };

    Formula.prototype.getModel = function () {
        return this.model;
    };

    Formula.prototype.setModel = function (model) {
        ensureParameter(model, 'model', 'object', 'setModel');
        var prefix = this.getPrefix();
        this.model = angular.copy(model);
        if(this.model.ComputableConcepts !== undefined && this.model.ComputableConcepts !== null && typeof this.model.ComputableConcepts === 'object'){
            for (var i in this.model.ComputableConcepts){
                var computableConcept = this.model.ComputableConcepts[i];
                if(computableConcept.indexOf(prefix + ':') === 0){
                    this.model.ComputableConcepts[i] = computableConcept.substring(computableConcept.indexOf(':')+1);
                }
            }
        }

        this.parser = null;
        this.compile();
    };

    Formula.prototype.Id = function() {
        return this.model.Id;
    };
    return Formula;
}]);


'use strict';

angular
.module('nolapReportEditor', ['reports.api.28.io'])
//http://angular-tips.com/blog/2014/03/transclusion-and-scopes/
.directive('reports', function($compile, ReportAPI){
    return {
        restrict: 'A',
        scope: {
            'reportApi': '@',
            'reportApiToken': '@'
        },
        transclude: true,
        controller: function($scope){
            var api = new ReportAPI($scope.reportApi);
            api.listReports({
                token: $scope.reportApiToken,
                $method: 'POST'
            })
            .then(function(reports){
                $scope.reports = reports;
            })
            .catch(function(error){
                console.error(error);
                $scope.error = error;
            });
        },
        link: function($scope, element, attrs, ctrl, $transclude){
            $transclude($scope, function(clone) {
                element.append(clone);
            });
        }
    };
})
.directive('report', function($rootScope, Report, ReportAPI){
    return {
        restrict: 'E',
        transclude: true,
        controller: function($scope){

            this.getReport = function(){
                return $scope.report;
            };
            
            this.getPresentationTree = function(){
                return this.getReport().getNetwork('Presentation').Trees;
            };

            this.getConceptMap = function(){
                return this.getReport().getNetwork('ConceptMap').Trees;
            };
        },
        link: function($scope, element, attrs, ctrl, $transclude){
            
            $scope.isInPresentation = function(concept){
                return $scope.report.findInTree('Presentation', concept.Name).length > 0;
            };
            
            $scope.isInConceptMap = function(concept){
                return $scope.report.findInConceptMap(concept.Name).length > 0;
            };
            
            $scope.isInBusinessRule = function(concept){
                return $scope.report.findInRules(concept.Name).length > 0;
            };
                    
            var api = new ReportAPI(attrs.reportApi);

            api.listReports({
                _id: attrs.reportId,
                token: attrs.reportApiToken,
                $method: 'POST'
            })
            .then(function(reports){
                $scope.model = reports[0];
                $scope.dirtyModel = angular.copy($scope.model);
                $scope.report = new Report($scope.dirtyModel);
            })
            .catch(function(error){
                console.error(error);
                $scope.error = error;
            });
            
            $transclude($scope, function(clone) {
                element.append(clone);
            });

            $scope.$watch('dirtyModel', function(dirtyModel, previousVersion){

                if(previousVersion === undefined || JSON.stringify(dirtyModel) === JSON.stringify(previousVersion)) {
                    return;
                }
  /*  
        var instance = jsondiffpatch.create({
        objectHash: function(obj) {
            return obj._id || obj.id || obj.name || JSON.stringify(obj);
        }
    });
    console.log(dirtyModel);
    console.log(previousVersion);
var delta = instance.diff(dirtyModel, previousVersion);
console.log(delta);
*/
                $rootScope.$emit('saving');
                api.addOrReplaceOrValidateReport({
                    report: dirtyModel,
                    token: attrs.reportApiToken,
                    $method: 'POST'
                })
                .then(function(){
                    $rootScope.$emit('saved');
                    console.log('new model saved');
                    $scope.model = angular.copy(dirtyModel);
                })
                .catch(function(error){
                    $rootScope.$emit('savingError');
                    console.error(error);
                    $scope.dirtyModel = angular.copy($scope.model);
                });
            }, true);
        }
    };
})
.directive('presentationTree', function($rootScope, PresentationTreeTpl) {

    var safeApply = function(scope, fn){
        scope.$apply(function(){
            try {
                fn();
            } catch (e) {
                $rootScope.$emit('error', 500, e.message);
            }
        });
    };

    return {
        restrict: 'E',
        scope: {
            'conceptName': '@'
        },
        template: PresentationTreeTpl,
        require: '^report',
        link: function($scope, element, attrs, reportCtrl) {
            $scope.sortableOptions = {
                placeholder: 'sortable',
                connectWith: '.sortable-container',
                receive: function(e, ui){
                    //var concept = ui.item.sortable.moved;
                    var dropIdx = ui.item.sortable.dropindex;
                    var parentIdx = dropIdx - 1;
                    var parentLevel = $scope.rows[dropIdx].level - 1;
                    var parent = $scope.rows[parentIdx];
                    while(parent.level !== parentLevel) {
                        parentIdx--;
                        parent = $scope.rows[parentIdx];
                    }
                    //networkShortName, parentElementID, conceptName, offset
                    //safeApply($scope, function(){
                        reportCtrl.getReport().addTreeChild('Presentation', parent.branch.Id, ui.item.text(), dropIdx - 1 - parentIdx);
                        ui.item.sortable.cancel();
                    //});
                },
                stop: function(e, ui){
                    var item = angular.element(ui.item);
                    var subtreeRootElementID = item.attr('id');
                    $scope.rows.forEach(function(row, index){
                        if(row.branch.Id === subtreeRootElementID) {
                            if(index === 0){
                                safeApply($scope, function(){
                                    reportCtrl.getReport().moveTreeBranch('Presentation', subtreeRootElementID);
                                });
                            } else {
                                //var currentLevel = row.level;
                                var siblingIdx = index - 1;
                                var parentIdx = index - 1;
                                //var sibling = $scope.rows[siblingIdx];
                                var parent = $scope.rows[parentIdx];
                                while(parent.level === row.level){
                                    parentIdx--;
                                    parent = $scope.rows[parentIdx];
                                }
                                safeApply($scope, function(){
                                    reportCtrl.getReport().moveTreeBranch('Presentation', subtreeRootElementID, parent.branch.Id, siblingIdx - parentIdx);
                                });
                            }
                            //$scope.presentationTree = reportCtrl.getPresentationTree();
                            return false;
                        }
                    });
                }
            };
            
            $scope.select = function(row) {
                if(row.branch.To) {
                    row.branch.expanded = !row.branch.expanded;
                    $scope.rows = setRows(reportCtrl.getPresentationTree(), 1, true, []);
                } else {
                    $scope.selected = row.branch;
                }
            };

            $scope.remove = function(id){
                $rootScope.$emit('removeConceptFromPresentationTree', id);  
            };

            var setRows = function(tree, level, visible, rows){
                if(visible === false) {
                    return; 
                }
                if(tree === undefined) {
                    console.log(tree);
                }
                Object.keys(tree).sort(function(elem1, elem2){
                    elem1 = tree[elem1];
                    elem2 = tree[elem2];
                    var order1 = elem1.Order;
                    if(order1 === undefined || order1 === null){
                        order1 = 1;
                    } else if(typeof order1 !== 'number'){
                        order1 = parseInt(order1, 10);
                    }
                    var order2 = elem2.Order;
                    if(order2 === undefined || order2 === null){
                        order2 = 1;
                    } else if(typeof order2 !== 'number'){
                        order2 = parseInt(order2, 10);
                    }
                    if (order1 < order2){
                        return -1;
                    }
                    if (order1 > order2){
                        return 1;
                    }
                    return 0;
                }).forEach(function(leaf){
                    var branch = tree[leaf];
                    branch.expanded = branch.expanded !== undefined ? branch.expanded : true;
                    rows.push({ branch: branch, level: level, visible: visible });
                    if(branch.To){
                        setRows(branch.To, level + 1, visible === false ? false : branch.expanded, rows);
                    }
                });
                return rows;
            };

            //$scope.rows = [];
            var onChange = function(tree){
                $scope.rows = setRows(tree, 1, true, []);
            };

            $scope.$watch(function(){
                return reportCtrl.getPresentationTree();
            }, onChange, true);
        }   
    };
})
.directive('conceptMap', function($rootScope, ConceptMapTpl) {
    return {
        restrict: 'E',
        scope: {
            'conceptName': '@'
        },
        template: ConceptMapTpl,
        require: '^report',
        link: function($scope, element, attrs, reportCtrl) {
            $scope.concept = reportCtrl.getReport().getConcept($scope.conceptName);
            $scope.map = reportCtrl.getConceptMap()[$scope.conceptName] === undefined ? undefined : Object.keys(reportCtrl.getConceptMap()[$scope.conceptName].To);

/*
            $scope.$watch(function(){
                return reportCtrl.getConcepts();
            }, function(concepts){
                $scope.concepts = [];
                concepts.forEach(function(concept){
                    $scope.concepts.push(concept.Name);
                });
            });
            */

            $scope.removeConceptMap = function(){
                reportCtrl.getReport().removeConceptMap($scope.conceptName);
                $scope.map = undefined;
            };

            $scope.addConceptMap = function(){
                try {
                    reportCtrl.getReport().addConceptMap($scope.conceptName, []);
                    $scope.map = [];
                } catch(e) {
                    $rootScope.$emit('error', 500, e.message);
                }
            };

            $scope.addValue = function(value){
                if($scope.concepts.indexOf(value) !== -1) {
                    $scope.map.push(value);
                    reportCtrl.getReport().updateConceptMap($scope.concept.Name, $scope.map);
                }
            };

            $scope.removeValue = function(value){
                if($scope.map.indexOf(value) !== -1) {
                    $scope.map.splice($scope.map.indexOf(value), 1);
                    reportCtrl.getReport().updateConceptMap($scope.concept.Name, $scope.map);
                }
            };
            
            $scope.moveTo = function(value, index) {
                var parent = reportCtrl.getConceptMap()[$scope.conceptName];
                var child = parent.To[value]; 
                reportCtrl.getReport().moveTreeBranch('ConceptMap', child.Id, parent.Id, index);
            };
        }
    };
})
.directive('concept', function($rootScope, ConceptTpl){
    return {
        restrict: 'E',
        scope: {
            'conceptName': '@'
        },
        template: ConceptTpl,
        require: '^report',
        link: function($scope, element, attrs, reportCtrl) {
            $scope.concept = reportCtrl.getReport().getConcept($scope.conceptName);

            $scope.remove = function(){
                try {
                    reportCtrl.getReport().removeConcept($scope.concept.Name);
                } catch(e) {
                    console.log(e);
                    $rootScope.$emit('error', 500, e.message);
                }
            };

            $scope.edit = function(){
                reportCtrl.getReport().updateConcept($scope.concept.Name, $scope.concept.Label, $scope.concept.IsAbstract);
            };
        }
    };
})
.directive('businessRules', function($rootScope, BusinessRuleTpl){
    return {
        restrict: 'E',
        scope: {
            'conceptName': '@',
            'report': '='
        },
        template: BusinessRuleTpl,
        link: function($scope) {

            $scope.hasComputingRule = false;
            $scope.hasValidatingRules = false;

            var updateRules = function(concept){
                if(concept === undefined || concept === null){
                    $scope.allRules = undefined;
                    $scope.hasComputingRule = false;

                    $scope.validatingRules = undefined;
                    $scope.hasValidatingRules = false;
                } else {
                    $scope.allRules = $scope.report.listRules(concept);
                    if($scope.allRules.length > 0){
                        $scope.hasComputingRule = true;
                    } else {
                        $scope.hasComputingRule = false;
                    }

                    $scope.validatingRules = $scope.report.listValidatingRules(concept);
                    if($scope.validatingRules.length > 0){
                        $scope.hasValidatingRules = true;
                    } else {
                        $scope.hasValidatingRules = false;
                    }
                }
            };
            updateRules($scope.conceptName);

            $scope.$watch(function(){
                return $scope.report.listRules();
            }, function(){
                updateRules($scope.conceptName);
            }, true);

            $scope.removeRule = function(id){
                $rootScope.$emit('removeRule', id);
            };

            $scope.addRule = function(concept, ruleType, language){
                $rootScope.$emit('createRule', concept, ruleType, language);
            };

            $scope.editRule = function(id) {
                $rootScope.$emit('editRule', id);
            };

        }
    };
})
.directive('rulesEditor', function($rootScope, RulesEditorTpl){
    return {
        restrict: 'E',
        scope: {
            'conceptName': '@',
            'formula': '=',
            'action': '='
        },
        template: RulesEditorTpl,
        link: function($scope) {
            $scope.colspan1 = 2;
            $scope.tooltipPlacement = 'top';
        }
    };
})
;
angular.module('reports.api.28.io', [])
/**
 * <p>This API can be used to manage reports.</p> <p>This API is only accesible for users having granted priviliges to work with reports.</p> <p>Note, that the POST method can be simulated by using GET and adding the _method=POST parameter to the HTTP request.</p>
 */
.factory('ReportAPI', function($q, $http, $rootScope){
    /**
     * @class ReportAPI
     * @param {string} domain - The project domain
     */
    return function(domain) {
        if(typeof(domain) !== 'string') {
            throw new Error('Domain parameter must be specified as a string.');
        }

        var root = '';

        this.$on = function($scope, path, handler) {
            var url = domain + path;
            $scope.$on(url, function(event, data){
                handler(data);
            });
            return this;
        };

        this.$broadcast = function(path, data){
            var url = domain + path;
            $rootScope.$broadcast(url, data);
            return this;
        };

        /**
         * 
         * @method
         * @name ReportAPI#listReports
         * @param {string} _id - A report id (e.g. FundamentalAccountingConcepts),
         * @param {string} token - The token of the current session,
         * 
         */
        this.listReports = function(parameters){
            var deferred = $q.defer();
            var that = this;
            var path = '/reports.jq'
            var url = domain + path;
            var params = {};
            params['_id'] = parameters['_id'];
            params['token'] = parameters['token'];
            var body = null;
            var method = 'GET'.toUpperCase();
            if (parameters.$method)
            {
                params['_method'] = parameters.$method;
                method = 'GET';
            }
            var cached = parameters.$cache && parameters.$cache.get(url);
            if(method === 'GET' && cached !== undefined && parameters.$refresh !== true) {
                deferred.resolve(cached);
            } else {
            $http({
                method: method,
                url: url,
                params: params,
                cache: (parameters.$refresh !== true)
            })
            .success(function(data, status, headers, config){
                deferred.resolve(data);
                //that.$broadcast(url);
                if(parameters.$cache !== undefined) parameters.$cache.put(url, data, parameters.$cacheItemOpts ?
parameters.$cacheItemOpts : {});
            })
            .error(function(data, status, headers, config){
                deferred.reject({data: data, status: status, headers: headers, config: config});
                //cache.removeAll();
            })
            ;
            }
            return deferred.promise;
        };

        /**
         * 
         * @method
         * @name ReportAPI#addOrReplaceOrValidateReport
         * @param {object} report - A JSON object containing the report,
         * @param {boolean} validation-only - This parameter is either given without any value (means: on) or absent (means: off) or its value is castable to a boolean. Turns validation-only mode on or off.,
         * @param {string} token - The token of the current session,
         * 
         */
        this.addOrReplaceOrValidateReport = function(parameters){
            var deferred = $q.defer();
            var that = this;
            var path = '/add-report.jq'
            var url = domain + path;
            var params = {};
            params['validation-only'] = parameters['validationOnly'];
            params['token'] = parameters['token'];
            var body = parameters['report'];
            var method = 'POST'.toUpperCase();
            if (parameters.$method)
            {
                params['_method'] = parameters.$method;
                method = 'POST';
            }
            var cached = parameters.$cache && parameters.$cache.get(url);
            if(method === 'GET' && cached !== undefined && parameters.$refresh !== true) {
                deferred.resolve(cached);
            } else {
            $http({
                method: method,
                url: url,
                params: params,
data: body,
                cache: (parameters.$refresh !== true)
            })
            .success(function(data, status, headers, config){
                deferred.resolve(data);
                //cache.removeAll();
            })
            .error(function(data, status, headers, config){
                deferred.reject({data: data, status: status, headers: headers, config: config});
                //cache.removeAll();
            })
            ;
            }
            return deferred.promise;
        };

        /**
         * 
         * @method
         * @name ReportAPI#removeReport
         * @param {string} _id - A report id (e.g. FundamentalAccountingConcepts),
         * @param {string} token - The token of the current session,
         * 
         */
        this.removeReport = function(parameters){
            var deferred = $q.defer();
            var that = this;
            var path = '/delete-report.jq'
            var url = domain + path;
            var params = {};
            if(parameters['_id'] === undefined) {
                deferred.reject(new Error('The _id parameter is required'));
                return deferred.promise;
            } else {
                params['_id'] = parameters['_id'];
            }
            params['token'] = parameters['token'];
            var body = null;
            var method = 'POST'.toUpperCase();
            if (parameters.$method)
            {
                params['_method'] = parameters.$method;
                method = 'GET';
            }
            var cached = parameters.$cache && parameters.$cache.get(url);
            if(method === 'GET' && cached !== undefined && parameters.$refresh !== true) {
                deferred.resolve(cached);
            } else {
            $http({
                method: method,
                url: url,
                params: params,
                cache: (parameters.$refresh !== true)
            })
            .success(function(data, status, headers, config){
                deferred.resolve(data);
                //cache.removeAll();
            })
            .error(function(data, status, headers, config){
                deferred.reject({data: data, status: status, headers: headers, config: config});
                //cache.removeAll();
            })
            ;
            }
            return deferred.promise;
        };
    };
});angular.module("nolapReportEditor")

.constant("PresentationTreeTpl", "<div ng-if=\"!conceptName\">\n    <p>No concept is selected. You can pick one on the left end side or create a new concept.</p>\n    <button ng-click=\"newConcept()\" class=\"btn btn-primary\"><i class=\"fa fa-plus\"></i> Concept</button>\n</div>\n<div ng-if=\"conceptName\">\n    <p>Drag and drop the concept in the presentation tree.</p>\n    <ul class=\"list-group sortable-container\" ui-sortable=\"sortableOptions\" ng-model=\"conceptName\">\n        <li class=\"list-group-item sortable\" ng-bind=\"conceptName\"></li>\n    </ul>\n</div>\n<ul class=\"nav nav-list nav-pills nav-stacked abn-tree sortable-container\" ui-sortable=\"sortableOptions\" ng-model=\"rows\">\n    <li ng-repeat=\"row in rows\"  ng-class=\"'level-' + {{ row.level }} + (selected.Id === row.branch.Id ? ' active':'')\" class=\"abn-tree-row sortable\" id=\"{{row.branch.Id}}\">\n        <a ng-click=\"select(row)\">\n            <i ng-class=\"{ 'fa-caret-right': !row.branch.expanded && row.branch.To, 'fa-caret-down': row.branch.expanded && row.branch.To }\" class=\"indented tree-icon fa\"></i>\n            <span class=\"indented tree-label\">{{row.branch.Label}} ({{row.branch.Name}})</span>\n            <span class=\"remove-concept indented fa fa-times\" ng-click=\"remove(row.branch.Id)\"></span>\n        </a>\n    </li>\n</ul>")

.constant("ConceptMapTpl", "<div ng-if=\"map === undefined\">\n    <h3 ng-bind=\"concept.Name\"></h3>\n    <div ng-if=\"concept.IsAbstract !== true\">\n        <p>There is no concept map associated to <i ng-bind=\"conceptName\"></i>.</p>\n        <button ng-click=\"addConceptMap()\" class=\"btn btn-primary\">Add concept Map</button>\n    </div>\n    <div ng-if=\"concept.IsAbstract === true\">\n        <p>This concept is abstract.</p>\n    </div>\n</div>\n<div ng-if=\"map !== undefined\">\n    <button class=\"pull-right btn btn-default\"><i class=\"fa fa-times\" ng-click=\"removeConceptMap()\"></i></button>\n    <h3 ng-bind=\"concept.Name\"></h3>\n    <p ng-bind=\"concept.Label\"></p>\n    <ul class=\"list-group\">\n        <li class=\"list-group-item clearfix\" ng-repeat=\"key in map\">\n            <span ng-bind=\"key\"></span>\n            <div class=\"btn-group pull-right\">\n                <button class=\"btn btn-default\" type=\"button\" ng-click=\"moveTo(key, $index - 1)\" ng-if=\"$last === false\"><i class=\"fa fa-long-arrow-down\"></i></button>\n                <button class=\"btn btn-default\" type=\"button\" ng-click=\"moveTo(key, $index + 1)\" ng-if=\"$first === false\"><i class=\"fa fa-long-arrow-up\"></i></button>\n                <button class=\"btn btn-default\" type=\"button\" ng-click=\"removeValue(key)\"><i class=\"fa fa-times\"></i></button>\n            </div>\n        </li>\n    </ul>\n    <form class=\"form-inline\" role=\"form\" ng-submit=\"addValue(newConceptValue)\" ui-keypress=\"{ 13:'addValue(newConceptValue)' }\">\n        <div class=\"form-group\">\n            <div class=\"row\">\n                <div class=\"col-lg-6\">\n                    <div class=\"input-group\">\n                        <input type=\"text\" class=\"form-control\" id=\"conceptValue\" placeholder=\"Concept Name\" ng-model=\"newConceptValue\" typeahead=\"concept for concept in concepts | filter:$viewValue | limitTo:8\">\n                        <span class=\"input-group-btn\">\n                            <button type=\"submit\" class=\"btn btn-primary\">Add</button>\n                        </span>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </form>\n</div>")

.constant("BusinessRuleTpl", "<div ng-if=\"hasComputingRule\">\n    <h2>Computing Rule</h2>\n    <table class=\"table table-hover\">\n        <thead>\n        <tr>\n            <th>Id</th>\n            <th>Label</th>\n            <th>Rule Type</th>\n            <th>Action</th>\n        </tr>\n        </thead>\n        <tbody>\n        <tr ng-repeat=\"(key, rule) in allRules\">\n            <td ng-bind=\"rule.Id\"></td>\n            <td ng-bind=\"rule.Label\"></td>\n            <td ng-bind=\"rule.Type\"></td>\n            <td>\n                <button type=\"button\" class=\"btn btn-primary\" ng-click=\"editRule(rule.Id)\">Edit Rule</button>\n                <button type=\"button\" class=\"btn btn-danger\" ng-click=\"removeRule(rule.Id)\">Delete Rule</button>\n            </td>\n        </tr>\n        </tbody>\n    </table>\n</div>\n<div ng-if=\"!hasComputingRule\">\n    <h2>Create a Business Rule to Compute a Fact</h2>\n    <h3>Excel Rule</h3>\n    <div>\n        <p class=\"\">Create a simple rule for concept \"{{conceptName}}\" using spreadsheet formula syntax.</p>\n        <form class=\"form-inline\" role=\"form\" ng-submit=\"addRule(conceptName, 'xbrl28:formula', 'SpreadsheetFormula')\">\n            <button type=\"submit\" class=\"btn btn-primary\">Add Simple Rule</button>\n        </form>\n    </div>\n    <h3>Advanced Rule</h3>\n    <div>\n        <p class=\"\">Create an advanced rule for concept \"{{conceptName}}\" using Jsoniq syntax (advanced users only).</p>\n        <form class=\"form-inline\" role=\"form\" ng-submit=\"addRule(conceptName, 'xbrl28:formula', undefined)\">\n            <button type=\"submit\" class=\"btn btn-primary\">Add Advanced Rule</button>\n        </form>\n    </div>\n    <h3>Validation Rule</h3>\n    <div>\n        <p class=\"\">Create an advanced validation rule for concept \"{{conceptName}}\" using Jsoniq syntax (advanced users only).</p>\n        <form class=\"form-inline\" role=\"form\" ng-submit=\"addRule(conceptName, 'xbrl28:validation', undefined)\">\n            <button type=\"submit\" class=\"btn btn-primary\">Add Validation Rule</button>\n        </form>\n    </div>\n</div>\n<div ng-if=\"hasComputingRule && allRules[0].Type !== 'xbrl28:validation'\">\n    <h2>Validating Rules for Concept \"{{conceptName}}\"</h2>\n    <table class=\"table table-hover\" ng-if=\"hasValidatingRules\">\n        <thead>\n        <tr>\n            <th>Id</th>\n            <th>Label</th>\n            <th>Rule Type</th>\n            <th>Action</th>\n        </tr>\n        </thead>\n        <tbody>\n        <tr ng-repeat=\"(key, rule) in validatingRules\">\n            <td ng-bind=\"rule.Id\"></td>\n            <td ng-bind=\"rule.Label\"></td>\n            <td ng-bind=\"rule.Type\"></td>\n            <td>\n                <button type=\"button\" class=\"btn btn-primary\" ng-click=\"editRule(rule.Id)\">Edit Rule</button>\n                <button type=\"button\" class=\"btn btn-danger\" ng-click=\"removeRule(rule.Id)\">Delete Rule</button>\n            </td>\n        </tr>\n        </tbody>\n    </table>\n    <div ng-if=\"!hasValidatingRules\">\n        <p class=\"alert alert-info\">There are no validation rules validating concept \"{{conceptName}}\", yet.</p>\n    </div>\n</div>")

.constant("RulesEditorTpl", "<div class=\"container\">\n    <form novalidate class=\"form-horizontal\" role=\"form\">\n        <div class=\"form-group\" ng-class=\"{'has-error': formula.model.IdErr!==undefined}\">\n            <label for=\"ruleID\" class=\"col-sm-{{colspan1}} control-label\">ID</label>\n            <div class=\"col-sm-{{12 - colspan1}}\">\n                <input ng-if=\"action === 'Create'\" type=\"text\" id=\"ruleID\" class=\"form-control\" ng-model=\"formula.model.Id\" ng-pattern=\"/^.+$/\" required ng-change=\"formula.validate(action)\">\n                <input ng-if=\"action === 'Update'\" type=\"text\" id=\"ruleID\" readonly=\"readonly\" class=\"form-control\" ng-model=\"formula.model.Id\" ng-pattern=\"/^.+$/\" required>\n            </div>\n            <div class=\"col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-if=\"formula.model.IdErr\">\n                <p ng-bind=\"formula.model.IdErr\" class=\"text-danger\"></p>\n            </div>\n        </div>\n        <div class=\"form-group\" ng-class=\"{'has-error': formula.model.LabelErr!==undefined}\">\n            <label for=\"ruleLabel\" class=\"col-sm-{{colspan1}} control-label\">Label</label>\n            <div class=\"col-sm-{{12 - colspan1}}\">\n                <input type=\"text\" id=\"ruleLabel\" class=\"form-control\" ng-model=\"formula.model.Label\" required ng-change=\"formula.validate(action)\">\n            </div>\n            <div class=\"col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-if=\"formula.model.LabelErr\">\n                <p ng-bind=\"formula.model.LabelErr\" class=\"text-danger\"></p>\n            </div>\n        </div>\n        <div class=\"form-group\" ng-class=\"{'has-error': formula.model.DescriptionErr!==undefined}\">\n            <label for=\"ruleDescription\" class=\"col-sm-{{colspan1}} control-label\">Description</label>\n            <div class=\"col-sm-{{12 - colspan1}}\">\n                <textarea class=\"form-control\" id=\"ruleDescription\" rows=\"3\" placeholder=\"\" ng-model=\"formula.model.Description\" ng-change=\"formula.validate(action)\"></textarea>\n            </div>\n            <div class=\"col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-if=\"formula.model.DescriptionErr\">\n                <p ng-bind=\"formula.model.DescriptionErr\" class=\"text-danger\"></p>\n            </div>\n        </div>\n        <div class=\"form-group\" ng-class=\"{'has-error': formula.model.ComputableConceptsErr!==undefined}\">\n            <label for=\"compFact\" class=\"col-sm-{{colspan1}} control-label\">Computed Fact Name</label>\n            <div class=\"col-sm-{{12 - colspan1}}\">\n                <input type=\"text\" id=\"compFact\" class=\"form-control\" ng-model=\"formula.model.ComputableConcepts\" ng-list ng-change=\"formula.validate(action)\">\n            </div>\n            <div class=\"col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-if=\"formula.model.ComputableConceptsErr\">\n                <p ng-bind=\"formula.model.ComputableConceptsErr\" class=\"text-danger\"></p>\n            </div>\n        </div>\n        <div class=\"form-group\" ng-class=\"{'has-error': formula.model.DependsOnErr!==undefined}\">\n            <label for=\"deps\" class=\"col-sm-{{colspan1}} control-label\">Dependencies</label>\n            <div class=\"col-sm-{{12 - colspan1}}\">\n                <input ng-if=\"formula.model.OriginalLanguage === 'SpreadsheetFormula'\"\n                       class=\"form-control\" ng-model=\"formula.model.DependsOn\" ng-list ng-change=\"formula.validate(action)\" type=\"text\" id=\"deps\" readonly>\n                <input ng-if=\"formula.model.OriginalLanguage !== 'SpreadsheetFormula'\"\n                       class=\"form-control\" ng-model=\"formula.model.DependsOn\" ng-list ng-change=\"formula.validate(action)\" type=\"text\" id=\"deps\">\n            </div>\n            <div class=\"col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-if=\"formula.model.DependsOnErr\">\n                <p ng-bind=\"formula.model.DependsOnErr\" class=\"text-danger\"></p>\n            </div>\n        </div>\n\n\n        <!-- if 'SpreadsheetFormula'-->\n        <div class=\"form-group\" ng-if=\"formula.model.OriginalLanguage === 'SpreadsheetFormula'\">\n            <label for=\"coverAspects\" class=\"col-sm-{{colspan1}} control-label\">Implicit Filtering Options</label>\n            <div class=\"col-sm-{{12 - colspan1}}\">\n                <input type=\"checkbox\" id=\"coverAspects\" ng-model=\"formula.model.AllowCrossPeriod\">\n                    <span tooltip=\"Allow facts to be computable across different period types (e.g. divide Revenue [duration] by Assets [instant]).\" tooltip-trigger=\"mouseenter\" tooltip-placement=\"{{tooltipPlacement}}\">\n                        Compute facts across different period types (duration/instant)</span>\n            </div>\n            <div class=\"col-sm-{{12 - colspan1}}\">\n                <input type=\"checkbox\" ng-model=\"formula.model.AllowCrossBalance\">\n                    <span tooltip=\"Allow facts to be computable across different balance types (e.g. allow to compare Assets [debit] with Equity [debit]).\" tooltip-trigger=\"mouseenter\" tooltip-placement=\"{{tooltipPlacement}}\">\n                        Compute facts across different balance types (debit/credit)</span>\n            </div>\n        </div>\n        <tabset ng-if=\"formula.model.OriginalLanguage === 'SpreadsheetFormula'\">\n            <tab ng-repeat=\"alt in formula.model.Formulae track by $index\" active=\"alt.active\">\n                <tab-heading>\n                    <span ng-class=\"{'text-danger': alt.valid===false}\"><i class=\"glyphicon glyphicon-bell\" style=\"color: #a94442\" ng-show=\"alt.valid===false\"></i> Alternative {{$index +1}}</span>\n                    <span class=\"btn-group\" dropdown is-open=\"status.isopen\" style=\"margin-left: 10px; margin-right: 10px;\">\n                        <button type=\"button\" class=\"btn btn-default dropdown-toggle btn-xs\" ng-disabled=\"disabled\"><span class=\"caret\"></span></button>\n                        <ul class=\"dropdown-menu\" role=\"menu\">\n                            <li ng-if=\"formula.model.Formulae.length > 1\"><a href=\"#\" ng-click=\"formula.removeAlternative($index)\" class=\"text-danger\"><i class=\"glyphicon glyphicon-trash\"></i> Delete</a></li>\n                            <li><a href=\"#\" ng-click=\"formula.copyAlternative($index)\"><i class=\"glyphicon glyphicon-share\"></i> Duplicate</a></li>\n                        </ul>\n                    </span>\n                </tab-heading>\n                <div style=\"border-width: 0 1px 1px 1px;border-color: #ddd;border-radius: 4px 4px 0 0;padding-top: 15px;\">\n                    <div class=\"form-group\" ng-class=\"{'has-error': alt.SourceFactErr!==undefined}\">\n                        <label for=\"sourceFact{{$index}}\" class=\"col-sm-{{colspan1}} control-label\">Mandatory Source Fact</label>\n                        <div class=\"col-sm-{{12 - colspan1}}\">\n                            <input type=\"text\" id=\"sourceFact{{$index}}\" class=\"form-control\" ng-model=\"alt.SourceFact[0]\" ng-pattern=\"/^.+$/\" ng-change=\"formula.validate(action)\">\n                        </div>\n                        <div class=\"col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-if=\"alt.SourceFactErr\">\n                            <p ng-bind=\"alt.SourceFactErr\" class=\"text-danger\"></p>\n                        </div>\n                    </div>\n                    <div class=\"form-group\" ng-class=\"{'has-error': alt.PrereqErr!==undefined}\">\n                        <label for=\"precondition{{$index}}\" class=\"col-sm-{{colspan1}} control-label\">Precondition</label>\n                        <div class=\"col-sm-{{12 - colspan1}}\">\n                            <textarea class=\"form-control\" id=\"precondition{{$index}}\" rows=\"1\" placeholder=\"\" ng-change=\"formula.compilePrereq($index, true, action)\" ng-model=\"alt.PrereqSrc\"></textarea>\n                        </div>\n                        <div class=\"container alert alert-danger col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-show=\"alt.PrereqErr\" style=\"margin-top: 20px;\">{{alt.PrereqErr}}</div>\n                    </div>\n                    <div class=\"form-group\" ng-class=\"{'has-error': alt.BodyErr!==undefined}\">\n                        <label for=\"rule{{$index}}\" class=\"col-sm-{{colspan1}} control-label\">Arithmetic Rule</label>\n                        <div  class=\"col-sm-{{12 - colspan1}}\">\n                            <textarea class=\"form-control\" id=\"rule{{$index}}\" rows=\"6\" placeholder=\"\" ng-change=\"formula.compileBody($index, true, action)\" ng-model=\"alt.BodySrc\"></textarea>\n                        </div>\n                        <div class=\"container alert alert-danger col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-show=\"alt.BodyErr\" style=\"margin-top: 20px;\">{{alt.BodyErr}}</div>\n                    </div>\n                </div>\n            </tab>\n            <tab select=\"formula.addAlternative()\">\n                <tab-heading>\n                    <span><i class=\"glyphicon glyphicon-plus\"></i> Add An Alternative</span>\n                </tab-heading>\n            </tab>\n        </tabset>\n\n        <!-- if 'xbrl28:formula' || 'xbrl28:validation'-->\n        <div ng-if=\"formula.model.Type === 'xbrl28:formula' && formula.model.OriginalLanguage !== 'SpreadsheetFormula'\">\n            <div class=\"form-group\" ng-class=\"{'has-error': formula.model.FormulaErr!==undefined}\">\n                <label for=\"rule\" class=\"col-sm-{{colspan1}} control-label\">Advanced Rule</label>\n                <div  class=\"col-sm-{{12 - colspan1}}\">\n                    <textarea class=\"form-control\" id=\"rule\" rows=\"20\" placeholder=\"\" ng-change=\"formula.compile()\" ng-model=\"formula.model.Formula\"></textarea>\n                </div>\n                <div class=\"container alert alert-danger col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-show=\"formula.model.FormulaErr\" style=\"margin-top: 20px;\">{{formula.model.FormulaErr}}</div>\n            </div>\n        </div>\n        <div ng-if=\"formula.model.Type === 'xbrl28:validation' && formula.model.OriginalLanguage !== 'SpreadsheetFormula'\">\n            <div class=\"form-group\" ng-class=\"{'has-error': formula.model.ValidatedConceptsErr!==undefined}\">\n                <label for=\"validatedConcept\" class=\"col-sm-{{colspan1}} control-label\">Validated Concept</label>\n                <div class=\"col-sm-{{12 - colspan1}}\">\n                    <input type=\"text\" id=\"validatedConcept\" class=\"form-control\" ng-model=\"formula.model.ValidatedConcepts\" ng-pattern=\"/^.+$/\" ng-list ng-change=\"formula.validate(action)\">\n                </div>\n                <div class=\"col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-if=\"formula.model.ValidatedConceptsErr\">\n                    <p ng-bind=\"formula.model.ComputableConceptsErr\" class=\"text-danger\"></p>\n                </div>\n            </div>\n            <div class=\"form-group\" ng-class=\"{'has-error': formula.model.FormulaErr!==undefined}\">\n                <label for=\"validation\" class=\"col-sm-{{colspan1}} control-label\">Advanced Validation Rule</label>\n                <div  class=\"col-sm-{{12 - colspan1}}\">\n                    <textarea class=\"form-control\" id=\"validation\" rows=\"20\" placeholder=\"\" ng-change=\"formula.compile()\" ng-model=\"formula.model.Formula\"></textarea>\n                </div>\n                <div class=\"container alert alert-danger col-sm-offset-{{colspan1}} col-sm-{{12 - colspan1}}\" ng-show=\"formula.model.FormulaErr\" style=\"margin-top: 20px;\">{{formula.model.FormulaErr}}</div>\n            </div>\n        </div>\n    </form>\n</div>")

.constant("ConceptTpl", "<form name=\"editConceptForm\" ng-submit=\"ok\" role=\"form\" spellcheck=\"false\" novalidate>\n    <div class=\"modal-header\">\n    <button class=\"pull-right btn btn-default\"><i class=\"fa fa-times\" ng-click=\"remove()\"></i></button>\n        <h3 class=\"modal-title\" ng-bind=\"concept.Name\"></h3>\n    </div>\n    <div class=\"modal-body\">\n        <div class=\"form-group\">\n            <label for=\"label\">Label</label>\n           <input type=\"text\" class=\"form-control\" id=\"label\" ng-model=\"concept.Label\" placeholder=\"Label\" required>\n        </div>\n        <div class=\"checkbox\">\n            <label>\n                <input type=\"checkbox\" ng-model=\"concept.IsAbstract\"> Abstract\n            </label>\n        </div>\n    </div>\n</form>")

;'use strict';

angular
.module('nolapReportEditor')
.factory('Report', function(){

    //Constructor
    var Report = function(modelOrName, label, description, role, prefix){
        if ( modelOrName === null) {
            throw new Error('new Report creation with null');
        } else if (typeof modelOrName !== 'object' &&
                   typeof modelOrName !== 'string') {
            throw new Error('new Report creation with invalid type ' + typeof modelOrName);
        } else if (typeof modelOrName === 'object') {
            this.model = modelOrName;
        } else if (typeof modelOrName === 'string'){
            this.model =
                {
                    '_id' : modelOrName,
                    'Archive' : null,
                    'Label' : label,
                    'Description': description,
                    'Role' : role,
                    'Networks' : [
                        {
                            'LinkName' : 'link:presentationLink',
                            'LinkRole' : role,
                            'ArcName' : 'link:presentationArc',
                            'ArcRole' : 'http://www.xbrl.org/2003/arcrole/parent-child',
                            'Kind' : 'InterConceptTreeNetwork',
                            'ShortName' : 'Presentation',
                            'CyclesAllowed' : 'undirected',
                            'Trees' : {}
                        }, {
                            'LinkName' : 'link:definitionLink',
                            'LinkRole' : role,
                            'ArcName' : 'link:definitionArc',
                            'ArcRole' : 'http://www.xbrlsite.com/2013/fro/arcrole/class-subClass',
                            'Kind' : 'InterConceptTreeNetwork',
                            'ShortName' : 'ConceptMap',
                            'CyclesAllowed' : 'undirected',
                            'Trees' : {}
                        }
                    ],
                    'Hypercubes' : {
                        'xbrl:DefaultHypercube' : {
                            'Name' : 'xbrl:DefaultHypercube',
                            'Label' : 'XBRL Implicit non-dimensional Hypercube',
                            'Aspects' : {
                                'xbrl:Concept' : {
                                    'Name' : 'xbrl:Concept',
                                    'Label' : 'Implicit XBRL Concept Dimension',
                                    'Domains' : {
                                        'xbrl:ConceptDomain' : {
                                            'Name' : 'xbrl:ConceptDomain',
                                            'Label' : 'Implicit XBRL Concept Domain',
                                            'Members' : {}
                                        }
                                    }
                                },
                                'xbrl:Period' : {
                                    'Name' : 'xbrl:Period',
                                    'Label' : 'Implicit XBRL Period Dimension'
                                },
                                'xbrl:Entity' : {
                                    'Name' : 'xbrl:Entity',
                                    'Label' : 'Implicit XBRL Entity Dimension'
                                }
                            }
                        }
                    },
                    'Rules' : []
                };
            if(prefix !== undefined || prefix !== null || typeof prefix === 'string'){
                this.model.Prefix = prefix;
            }
        } // if
    };

    var ConceptIsStillReferencedError = function(message, referencesInConceptMapsArray, referencesInPresentationArray, referencesInRulesArray) {
        this.name = 'ConceptIsStillReferencedError';
        this.message = (message || '');
        this.references = {
            'Presentation': referencesInPresentationArray,
            'ConceptMaps' : referencesInConceptMapsArray,
            'Rules': referencesInRulesArray
        };
    };
    ConceptIsStillReferencedError.prototype = new Error();

    // helper function to check parameters
    var ensureNetworkShortName = function(networkShortName, paramName, functionName) {
        ensureParameter(networkShortName, paramName, 'string', functionName, /^(Presentation)|(ConceptMap)$/g,
            'invalid networkShortName parameter value passed "' + networkShortName + '" (allowed values: Presentation, ConceptMap).');
    };

    var ensureConceptName = function(conceptName, paramName, functionName, errorMsg) {
        var regex = /^\w(\w|\d|[-_])*:(\w|\d|[-_])*$/g;
        if(errorMsg === undefined || errorMsg === null) {
            ensureParameter(conceptName, paramName, 'string', functionName, regex,
                    'function called with mandatory "' + paramName + '" parameter which is not a QName: ' + conceptName);
        } else {
            if(conceptName.match(regex) === null) {
                throw new Error(errorMsg);
            }
        }
    };
    
    var ensureRuleType = function(ruleType, paramName, functionName) {
        ensureParameter(ruleType, paramName, 'string', functionName, /^(xbrl28:validation)|(xbrl28:formula)$/g,
            'rule type "' + ruleType + '" is not a valid type (allowed types: xbrl28:validation, xbrl28:formula)');
    };

    var ensureParameter = function(paramValue, paramName, paramType, functionName, regex, regexErrorMessage) {
        if(paramValue === null || paramValue === undefined) {
            throw new Error(functionName + ': function called without mandatory "' + paramName + '" parameter.');
        }
        if(typeof paramValue !== paramType) {
            throw new Error(functionName + ': function called with mandatory "' + paramName + '" parameter which is of wrong type "' + typeof paramValue + '" (should be of type "' + paramType + '" instead).');
        }
        if(regex !== undefined && paramValue.match(regex) === null) {
            throw new Error(functionName + ': ' + regexErrorMessage);
        }
    };

    var ensureExists = function(value, valueType, functionName, errorMessage) {
        if(value === null || value === undefined || value === '') {
            throw new Error(functionName + ': ' + errorMessage);
        }
        if(typeof value !== valueType) {
            throw new Error(functionName + ': Type exception: Expected type "' + valueType + '"');
        }
    };

    // helper to create a unique id
    var _uuid = function () {
        // thanks to https://gist.github.com/ae6rt/7894539
        // http://www.ietf.org/rfc/rfc4122.txt
        var s = [];
        var hexDigits = '0123456789abcdef';
        for (var i = 0; i < 36; i++) {
            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
        }
        s[14] = '4';  // bits 12-15 of the time_hi_and_version field to 0010
        /* jslint bitwise: true */
        s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01
        /* jslint bitwise: false */
        s[8] = s[13] = s[18] = s[23] = '-';
        return s.join('');
    };

    Report.prototype.uuid = function(){
        return _uuid();
    };

    Report.prototype.getPrefix = function(){
        var model = this.getModel();
        ensureExists(model, 'object', 'getPrefix', 'Report doesn\'t have a model.');
        if(model.Prefix !== undefined && model.Prefix !== null && typeof model.Prefix === 'string'){
           return model.Prefix;
        }

        // try to guess the prefix
        var concepts = this.listConcepts();
        if(concepts.length === 0){
            // no chance to guess the prefix
            return null;
        }
        var map = concepts.reduce(function (prefixes, concept) {
            var found = concept.Name.indexOf(':');
            if(found !== -1){
                var prefix = concept.Name.substring(0,found);
                prefixes[prefix] = (prefixes[prefix] || 0) + 1;
            }
            return prefixes;
        }, {});
        var allPrefixes = Object.keys(map).sort(function (a, b) {
            return map[a] < map[b];
        });
        model.Prefix = allPrefixes[0];
        return model.Prefix;
    };

    Report.prototype.getModel = function(){
        return this.model;
    };

    /**********************
     ** Concepts API
     **********************/
    Report.prototype.addConcept = function(name, label, abstract) {
        ensureConceptName(name, 'name', 'addConcept');
        ensureParameter(label, 'label', 'string', 'addConcept');
        ensureParameter(abstract, 'abstract', 'boolean', 'addConcept');
        
        if(this.existsConcept(name)) {
            throw new Error('addConcept: concept with name "' + name + '" already exists.');
        }

        var model = this.getModel();
        var concept =
            {
                'Name': name,
                'Label': label,
                'IsAbstract': abstract
                /* still to be implemented:
                'IsNillable': false,
                'PeriodType': duration,
                'SubstitutionGroup': 'xbrl:item',
                'DataType' : 'nonnum:textBlockItemType', 
                'BaseType' : 'xs:string', 
                'ClosestSchemaBuiltinType' : 'xs:string', 
                'IsTextBlock' : true
                */
            };
        model.Hypercubes['xbrl:DefaultHypercube']
            .Aspects['xbrl:Concept']
            .Domains['xbrl:ConceptDomain']
            .Members[name] = concept;
    };

    Report.prototype.updateConcept = function(name, label, abstract) {
        ensureConceptName(name, 'name', 'updateConcept');
        ensureParameter(label, 'label', 'string', 'updateConcept');
        abstract = abstract === true;

        if(!this.existsConcept(name)) {
            throw new Error('updateConcept: cannot update concept with name "' + name + '" because it doesn\'t exist.');
        }
       
        var concept = this.getConcept(name);
        concept.Label = label;
        concept.IsAbstract = abstract;
    };

    Report.prototype.removeConcept = function(name) {
        ensureConceptName(name, 'name', 'removeConcept');

        if(!this.existsConcept(name)){
            throw new Error('removeConcept: cannot remove concept with name "' + name + '" from model because it doesn\'t exist.');
        }

        var referencesInConceptMapsArray = this.findInConceptMap(name);
        var referencesInPresentationArray = this.findInTree('Presentation', name);
        var referencesInRulesArray = this.findInRules(name);
        if(referencesInConceptMapsArray.length > 0 || referencesInPresentationArray.length > 0 || referencesInRulesArray.length > 0){
            throw new ConceptIsStillReferencedError('removeConcept: cannot remove concept with name "' + name + '" from model because it is still referenced in the report.', referencesInConceptMapsArray, referencesInPresentationArray, referencesInRulesArray);
        }

        var model = this.getModel();
        delete model.Hypercubes['xbrl:DefaultHypercube']
            .Aspects['xbrl:Concept']
            .Domains['xbrl:ConceptDomain']
            .Members[name];
    };

    Report.prototype.existsConcept = function(conceptName) {
        ensureConceptName(conceptName, 'conceptName', 'existsConcept');

        var concept = this.getConcept(conceptName);
        if(concept !== null && typeof concept === 'object') {
            return true;
        }
        return false;
    };

    Report.prototype.getConcept = function(conceptName) {
        ensureConceptName(conceptName, 'conceptName', 'getConcept');

        var model = this.getModel();
        if(model === null || model === undefined) {
            return null;
        }

        var concept =
          model.Hypercubes['xbrl:DefaultHypercube']
              .Aspects['xbrl:Concept']
              .Domains['xbrl:ConceptDomain']
              .Members[conceptName];

        if(concept === null || concept === undefined) {
            return null;
        }
        return concept;
    };

    Report.prototype.listConcepts = function() {

        var result = [];
        var model = this.getModel();
        if(model === null || model === undefined) {
            return result;
        }

        var members =
            model.Hypercubes['xbrl:DefaultHypercube']
                .Aspects['xbrl:Concept']
                .Domains['xbrl:ConceptDomain']
                .Members;
        if(members === null || members === undefined) {
            return result;
        }

        for(var conceptname in members) {
            var concept = members[conceptname];
            result.push(concept);
        }
        return result;
    };

    /**********************
     ** Trees API
     **********************/
    Report.prototype.getNetwork = function(networkShortName) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'getNetwork');
        
        var model = this.getModel();
        if(model === null || model === undefined) {
            return null;
        }

        var networks = model.Networks;
        if(networks === null || networks === undefined) {
            return null;
        }

        for(var i in networks) {
            var network = networks[i];
            if(networks.hasOwnProperty(i) &&
                network.ShortName === networkShortName){
                return network;
            }
        }
    };

    Report.prototype.listTrees = function(networkShortName) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'listTrees');
        
        var result = [];
        var network = this.getNetwork(networkShortName);
        if(network === null || network === undefined) {
            return result;
        }

        for(var treeroot in network.Trees) {
            var tree = network.Trees[treeroot];
            result.push(tree);
        }
        return result;
    };

    Report.prototype.findInSubTree = function(conceptName, subtree) {
        var result = [];
        if(subtree.Name === conceptName){
            result.push(subtree.Id);
        }
        var children = subtree.To;
        for(var child in children){
            if(children.hasOwnProperty(child)) {
                var childresult = this.findInSubTree(conceptName, children[child]);
                Array.prototype.push.apply(result, childresult);
            }
        }
        return result;
    };
    
    Report.prototype.findInTree = function(networkShortName, conceptName) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'findInTree');
        
        var network = this.getNetwork(networkShortName);
        var result = [];
        var children = network.Trees;
        for(var child in children){
            if(children.hasOwnProperty(child)) {
                var childresult = this.findInSubTree(conceptName, children[child]);
                Array.prototype.push.apply(result, childresult);
            }
        }
        return result;
    };

    var getElementByIdFromSubTree = function(elementID, subtree) {
        if(subtree.Id === elementID){
            return subtree;
        }
        var children = subtree.To;
        for(var child in children){
            if(children.hasOwnProperty(child)) {
                var childresult = getElementByIdFromSubTree(elementID, children[child]);
                if(childresult !== null) {
                    return childresult;
                }
            }
        }
        return null;
    };

    Report.prototype.getElementFromTree = function(networkShortName, elementID) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'getElementFromTree');
        ensureParameter(elementID, 'elementID', 'string', 'getElementFromTree');
        
        var network = this.getNetwork(networkShortName);
        var element = null;
        var children = network.Trees;
        for(var child in children){
            if(children.hasOwnProperty(child)) {
                var childresult = getElementByIdFromSubTree(elementID, children[child]);
                if(childresult !== null) {
                    element = childresult;
                }
            }
        }
        return element;
    };

    var enforceStrictChildOrderAndShift = function(report, networkShortName, parentID, shiftOffset) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'enforceStrictChildOrder');

        if(shiftOffset === undefined || shiftOffset === null){
            shiftOffset = -1;
        }
        var network = report.getNetwork(networkShortName);
        var children = network.Trees;
        if(parentID !== undefined && parentID !== null) {
            ensureParameter(parentID, 'parentID', 'string', 'enforceStrictChildOrder');
            var parent = report.getElementFromTree(networkShortName, parentID);
            ensureExists(parent, 'object', 'enforceStrictChildOrder', 'cannot enforce strict child order. Parent with id "' + parentID + '" doesn\'t exist.');
            children = parent.To;
        }

        var ordered = [];
        for(var child in children){
            if(children.hasOwnProperty(child)) {
                ordered.push(children[child]);
            }
        }
        ordered.sort(function(elem1, elem2){
            var order1 = elem1.Order;
            if(order1 === undefined || order1 === null){
                order1 = 1;
            } else if(typeof order1 !== 'number'){
                order1 = parseInt(order1, 10);
            }
            var order2 = elem2.Order;
            if(order2 === undefined || order2 === null){
                order2 = 1;
            } else if(typeof order2 !== 'number'){
                order2 = parseInt(order2, 10);
            }
            if (order1 < order2){
                return -1;
            }
            if (order1 > order2){
                return 1;
            }
            return 0;
        });
        for (var i = 0; i < ordered.length; i++) {
            if(shiftOffset !== -1 && i >= shiftOffset){
                ordered[i].Order = i + 2;
            } else {
                ordered[i].Order = i + 1;
            }
        }
    };

    var getParentElementFromSubTree = function(elementID, subtree) {
        var children = subtree.To;
        for(var child in children){
            if(children.hasOwnProperty(child)) {
                if(children[child].Id === elementID) {
                    return subtree;
                } else {
                    var childresult = getParentElementFromSubTree(elementID, children[child]);
                    if(childresult !== null) {
                        return childresult;
                    }
                }
            }
        }
        return null;
    };

    Report.prototype.getParentElementFromTree = function(networkShortName, elementID) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'getParentElementFromTree');
        ensureParameter(elementID, 'elementID', 'string', 'getParentElementFromTree');
        
        var network = this.getNetwork(networkShortName);
        var parent = null;
        var children = network.Trees;
        for(var child in children){
            if(children.hasOwnProperty(child)) {
                var result = getParentElementFromSubTree(elementID, children[child]);
                if(result !== null) {
                    parent = result;
                }
            }
        }
        return parent;
    };

    Report.prototype.existsElementInTree = function(networkShortName, elementID) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'existsElementInTree');
        ensureParameter(elementID, 'elementID', 'string', 'existsElementInTree');
        
        var element = this.getElementFromTree(networkShortName, elementID);
        if(element !== null && typeof element === 'object') {
            return true;
        }
        return false;
    };

    var createNewElement = function(concept, order) {
        ensureParameter(concept, 'concept', 'object', 'createNewElement');
        var _order = 1;
        if(order !== undefined) {
            ensureParameter(order, 'order', 'number', 'createNewElement');
            _order = order;
        }
        var element = {
            Id: _uuid(),
            Name : concept.Name,
            Label : concept.Label,
            Order : _order
        };
        return element;
    };

    var getMaxOrder = function(report, networkShortName, parentElementID){
        ensureNetworkShortName(networkShortName, 'networkShortName', 'getMaxOrder');
        var network = report.getNetwork(networkShortName);
        var children = network.Trees;
        if(parentElementID !== undefined && parentElementID !== null) {
            var parent = report.getElementFromTree(networkShortName, parentElementID);
            children = parent.To;
        }
        var count = 0, child;
        for (child in children) {
            if (children.hasOwnProperty(child)) {
                count += 1;
            }
        }
        return count;
    };

    Report.prototype.addTreeChild = function(networkShortName, parentElementID, conceptName, offset) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'addTreeChild');
        ensureConceptName(conceptName, 'conceptName', 'addTreeChild');
        var concept = this.getConcept(conceptName);
        ensureExists(concept, 'object', 'addTreeChild', 'concept with name "' + conceptName + '" doesn\'t exist.');

        var order = 1;
        var maxOrder = getMaxOrder(this, networkShortName, parentElementID);
        if(offset !== undefined && offset !== null){
            ensureParameter(offset, 'offset', 'number', 'addTreeChild');
            order = offset + 1;
        } else {
            offset = 0; // default
        }
        if(offset > (maxOrder)){
            throw new Error('addTreeChild: offset out of bounds: ' + offset +
                ' (Max offset is ' + maxOrder + ' for parent ' + parentElementID  + '.');
        }
        enforceStrictChildOrderAndShift(this, networkShortName, parentElementID, offset);
        if(parentElementID === undefined || parentElementID === null) {
            // add a root element
            var network = this.getNetwork(networkShortName);
            var rootElement = createNewElement(concept, order);
            network.Trees[conceptName] = rootElement;
            return rootElement;

        } else {
            // add child to existing tree
            ensureParameter(parentElementID, 'parentElementID', 'string', 'addTreeChild');
        
            var parent = this.getElementFromTree(networkShortName, parentElementID);
            ensureExists(parent, 'object', 'addTreeChild', 'cannot add child to tree. Parent with id "' + parentElementID + '" doesn\'t exist.');
            var parentConcept = this.getConcept(parent.Name);
            if(!parentConcept.IsAbstract) {
                throw new Error('addTreeChild: cannot add child to parent "' + parentElementID +
                    '". Reason: Parent concept "' + parent.Name  + '" is not abstract.');
            }

            var element = createNewElement(concept, order);
            if(parent.To === undefined || parent.To === null) {
                parent.To = {};
            }
            parent.To[conceptName] = element;

            return element;
        }
    };

    Report.prototype.moveTreeBranch = function(networkShortName, subtreeRootElementID, newParentElementID, newOffset) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'moveTreeBranch');
        ensureParameter(subtreeRootElementID, 'subtreeRootElementID', 'string', 'moveTreeBranch');

        var newOrder = 1;
        var maxOrder = getMaxOrder(this, networkShortName, newParentElementID);
        if(newOffset !== undefined && newOffset !== null){
            ensureParameter(newOffset, 'newOffset', 'number', 'moveTreeBranch');
            newOrder = newOffset + 1;
        } else {
            newOffset = 0; // default
        }
        if(newOffset > (maxOrder)){
            throw new Error('moveTreeBranch: offset out of bounds: ' + newOffset +
                ' (Max offset is ' + maxOrder + ' for parent ' + newParentElementID  + '.');
        }
        if(newParentElementID !== undefined && newParentElementID !== null){
            ensureParameter(newParentElementID, 'newParentElementID', 'string', 'moveTreeBranch');

            var newParent = this.getElementFromTree(networkShortName, newParentElementID);
            ensureExists(newParent, 'object', 'moveTreeBranch', 'Cannot move element with id "' + subtreeRootElementID + '" to new parent element with id "' + newParentElementID + '": Parent element doesn\'t exist.');
            var parentConcept = this.getConcept(newParent.Name);
            if(networkShortName !== 'ConceptMap' && !parentConcept.IsAbstract) {
                throw new Error('moveTreeBranch: cannot move element to target parent "' + newParentElementID +
                    '". Reason: Parent concept "' + newParent.Name  + '" is not abstract.');
            } else if(networkShortName === 'ConceptMap' && parentConcept.IsAbstract) {
                throw new Error('moveTreeBranch: cannot move element to target parent "' + newParentElementID +
                    '" in ConceptMap. Reason: Parent concept "' + newParent.Name  + '" is abstract.');
            }

            var element = this.removeTreeBranch(networkShortName, subtreeRootElementID);
            enforceStrictChildOrderAndShift(this, networkShortName, newParentElementID, newOffset);
            element.Order = newOrder;
            if(newParent.To === undefined || newParent.To === null) {
                newParent.To = {};
            }
            newParent.To[element.Name] = element;
        } else {
            // no new parent given -> make it a root element
            var network = this.getNetwork(networkShortName);
            var element2 = this.removeTreeBranch(networkShortName, subtreeRootElementID);
            enforceStrictChildOrderAndShift(this, networkShortName, newParentElementID, newOffset);
            element2.Order = newOrder;
            if(network.Trees === undefined || network.Trees === null) {
                network.Trees = [];
            }
            network.Trees[element2.Name] = element2;
        }
    };

    Report.prototype.removeTreeBranch = function(networkShortName,subtreeRootElementID) {
        ensureNetworkShortName(networkShortName, 'networkShortName', 'removeTreeBranch');
        ensureParameter(subtreeRootElementID, 'subtreeRootElementID', 'string', 'removeTreeBranch');

        var element = this.getElementFromTree(networkShortName, subtreeRootElementID);
        ensureExists(element, 'object', 'removeTreeBranch', 'Cannot remove element with id "' + subtreeRootElementID + '" from network: Element doesn\'t exist.');
        var parent = this.getParentElementFromTree(networkShortName, subtreeRootElementID);
        if(parent === null || parent === undefined) {
            var network = this.getNetwork(networkShortName);
            delete network.Trees[element.Name];
        } else {
            delete parent.To[element.Name];
        }
        return element;
    };

    /**********************
     ** Concept Maps API
     **********************/
    Report.prototype.getConceptMap = function(conceptName) {
        ensureConceptName(conceptName, 'conceptName', 'getConceptMap');

        var network = this.getNetwork('ConceptMap');
        if(network === null || network === undefined || network.Trees === null || network.Trees === undefined) {
            return null;
        }
 
        var map = network.Trees[conceptName];
        if(map === null || map === undefined) {
            return null;
        } else {
            return map;
        }
    };

    Report.prototype.listConceptMaps = function() {

        var result = [];
        var network = this.getNetwork('ConceptMap');
        if(network === null || network === undefined || network.Trees === null || network.Trees === undefined) {
            return result;
        }
        
        for (var conceptname in network.Trees) {
            var map = network.Trees[conceptname];
            result.push(map);
        }
        return result;
    };

    Report.prototype.existsConceptMap = function(conceptName) {
        ensureConceptName(conceptName, 'conceptName', 'existsConceptMap');

        var map = this.getConceptMap(conceptName);
        if(map === null || map === undefined) {
            return false;
        }
        return true;
    };

    Report.prototype.addConceptMap = function(fromConceptName, toConceptNamesArray) {
        ensureConceptName(fromConceptName, 'fromConceptName', 'addConceptMap');
        var fromConcept = this.getConcept(fromConceptName);
        ensureExists(fromConcept, 'object', 'addConceptMap', 'concept with name "' + fromConceptName + '" doesn\'t exist.');
        if(fromConcept.IsAbstract) {
            throw new Error('addConceptMap: cannot add a concept map for concept "' + fromConceptName +
                '". Reason: Concept is abstract.');
        }

        var toObj = {};
        for(var i in toConceptNamesArray) {
            var name = toConceptNamesArray[i];
            ensureConceptName(name, 'toConceptNamesArray', 'addConceptMap');
            toObj[name] = {
                'Id': _uuid(),
                'Name': name,
                'Order': parseInt(i, 10) + 1
            };
        }
        var conceptMap = {
            'Id': _uuid(),
            'Name': fromConcept.Name,
            'To': toObj
        };
        
        var network = this.getNetwork('ConceptMap');
        if(network.Trees === null || network.Trees === undefined) {
            network.Trees = {};
        }
        if(network.Trees[fromConceptName] !== null && typeof network.Trees[fromConceptName] === 'object'){
            throw new Error('addConceptMap: concept map for concept "' + fromConceptName + '" already exists');
        }
        network.Trees[fromConceptName] = conceptMap;
    };

    Report.prototype.updateConceptMap = function(fromConceptName, toConceptNamesArray) {
        ensureConceptName(fromConceptName, 'fromConceptName', 'updateConceptMap');
        var fromConcept = this.getConcept(fromConceptName);
        ensureExists(fromConcept, 'object', 'updateConceptMap', 'concept with name "' + fromConceptName + '" doesn\'t exist.');

        var conceptMap = this.getConceptMap(fromConceptName);
        ensureExists(conceptMap, 'object', 'updateConceptMap', 'No concept map exists for concept with name "' + fromConceptName + '".');

        var toObj = {};
        for(var i in toConceptNamesArray) {
            var name = toConceptNamesArray[i];
            ensureConceptName(name, 'toConceptNamesArray', 'updateConceptMap');
            toObj[name] = {
                'Name': name,
                'Order': parseInt(i, 10) + 1
            };
        }
        conceptMap.To = toObj;
    };

    Report.prototype.findInConceptMap = function(conceptName) {
        ensureConceptName(conceptName, 'conceptName', 'findInConceptMap');
        
        var result = [];
        var network = this.getNetwork('ConceptMap');
        if(network.Trees === null || network.Trees === undefined) {
            return result;
        }

        for(var child in network.Trees){
            if(network.Trees.hasOwnProperty(child)) {
                var map = network.Trees[child];
                var to = map.To;
                if(to !== null && to !== undefined && to[conceptName] !== null && typeof to[conceptName] === 'object') {
                    result.push(child);
                } else if (child === conceptName){
                    result.push(child);
                }
            }
        }
        return result;
    };

    Report.prototype.removeConceptMap = function(conceptName) {
        ensureConceptName(conceptName, 'conceptName', 'removeConceptMap');
        
        var conceptMap = this.getConceptMap(conceptName);
        ensureExists(conceptMap, 'object', 'removeConceptMap', 'No concept map exists for concept with name "' + conceptName + '".');

        var network = this.getNetwork('ConceptMap');
        return delete network.Trees[conceptName];
    };

    /**********************
     ** Rules API
     **********************/
    Report.prototype.getRule = function(id) {
        ensureParameter(id, 'id', 'string', 'getRule');

        var model = this.getModel();
        if(model === null || model === undefined || model.Rules === null || model.Rules === undefined || model.Rules.length === 0) {
            return null;
        }

        for (var i in model.Rules) {
            var rule = model.Rules[i];
            if(rule.Id === id) {
                return rule;
            }
        }
        return null;
    };

    Report.prototype.removeRule = function(id) {
        ensureParameter(id, 'id', 'string', 'removeRule');

        var model = this.getModel();
        if(model === null || model === undefined || model.Rules === null || model.Rules === undefined || model.Rules.length === 0) {
            return;
        }
        for (var i in model.Rules) {
            var rule = model.Rules[i];
            if(rule.Id === id) {
                // remove rule from array
                model.Rules.splice(i,1);
            }
        }
    };

    Report.prototype.existsRule = function(id) {
        ensureParameter(id, 'id', 'string', 'existsRule');

        var rule = this.getRule(id);
        if(rule !== null && typeof rule === 'object') {
            return true;
        }
        return false;
    };

    Report.prototype.validatedByRules = function(conceptName) {
        ensureConceptName(conceptName, 'conceptName', 'validatedByRules');

        var result = [];
        var model = this.getModel();
        ensureExists(model, 'object', 'validatedByRules', 'Report doesn\'t have a model.');

        if(model.Rules === null || model.Rules === undefined || model.Rules.length === 0) {
            return result;
        }

        for (var i in model.Rules) {
            var rule = model.Rules[i];
            if(rule.ValidatedConcepts !== undefined && rule.ValidatedConcepts !== null) {
                for (var j in rule.ValidatedConcepts) {
                    if (rule.ValidatedConcepts[j] === conceptName) {
                        result.push(rule);
                        break;
                    }
                }
            }
        }
        return result;
    };

     Report.prototype.computableByRules = function(conceptName) {
        ensureConceptName(conceptName, 'conceptName', 'computableByRules');

        var result = [];
        var model = this.getModel();
        ensureExists(model, 'object', 'computableByRules', 'Report doesn\'t have a model.');

        if(model.Rules === null || model.Rules === undefined || model.Rules.length === 0) {
            return result;
        }

        for (var i in model.Rules) {
            var rule = model.Rules[i];
            // indexOf not supported in IE<9
            for(var j in rule.ComputableConcepts){
                if(rule.ComputableConcepts[j] === conceptName) {
                    result.push(rule);
                }
            }
        }
        return result;
    };

    Report.prototype.findInRules = function(conceptName) {
        ensureConceptName(conceptName, 'conceptName', 'findInRules');

        var result = [];
        var model = this.getModel();
        ensureExists(model, 'object', 'findInRules', 'Report doesn\'t have a model.');

        if(model.Rules === null || model.Rules === undefined || model.Rules.length === 0) {
            return result;
        }

        for (var i in model.Rules) {
            var rule = model.Rules[i];
            var found = false;
            // indexOf not supported in IE<9
            for(var j in rule.ComputableConcepts){
                if(rule.ComputableConcepts[j] === conceptName) {
                    result.push(rule.Id);
                    found = true;
                    break;
                }
            }
            if(!found && rule.DependsOn !== null && typeof rule.DependsOn === 'object') {
                for(var x in rule.DependsOn){
                    if(rule.DependsOn[x] === conceptName) {
                        result.push(rule.Id);
                        found = true;
                        break;
                    }
                }
            }
            if(!found && rule.ValidatedConcepts !== null && typeof rule.ValidatedConcepts === 'object') {
                for(var y in rule.ValidatedConcepts){
                    if(rule.ValidatedConcepts[y] === conceptName) {
                        result.push(rule.Id);
                        found = true;
                        break;
                    }
                }
            }
        }
        return result;
    };

    var createNewRule = function(id, label, description, type, formula, computableConceptsArray, dependingConceptsArray, validatedConceptsArray, report) {
        ensureParameter(id, 'id', 'string', 'createNewRule');
        ensureParameter(label, 'label', 'string', 'createNewRule');
        ensureRuleType(type, 'type', 'createNewRule');
        ensureParameter(formula, 'formula', 'string', 'createNewRule');
        ensureExists(computableConceptsArray, 'object', 'createNewRule', 'function called without computableConceptsArray.');

        for(var i in computableConceptsArray) {
            var cname = computableConceptsArray[i];
            ensureConceptName(cname, 'computableConceptsArray', 'createNewRule');
            var rulesComputableConcepts = report.computableByRules(cname);
            if(rulesComputableConcepts.lenght > 0 && rulesComputableConcepts[0].Id !== id) {
                throw new Error('createNewRule: A rule which can compute facts of concept "' + cname + '" exists already: "' + rulesComputableConcepts[0] + '. Currently, only one rule must be able to compute a fact for a certain concept.');
            }
        }
        if(dependingConceptsArray !== null && typeof dependingConceptsArray === 'object') {
            for(var j in dependingConceptsArray) {
                var dname = dependingConceptsArray[j];
                ensureConceptName(dname, 'dependingConceptsArray', 'createNewRule');
            }
        }
        if(validatedConceptsArray !== null && typeof validatedConceptsArray === 'object') {
            for(var x in validatedConceptsArray) {
                var vname = validatedConceptsArray[x];
                ensureConceptName(vname, 'validatedConceptsArray', 'createNewRule');
            }
        }
        if(computableConceptsArray.length === 0) {
            throw new Error('createNewRule: rule of type "' + type + '" must have at least one computable concept. Function createNewRule was called with empty computableConceptsArray.');
        }
        
        var rule = {
            'Id': id,
            'Label': label,
            'Description': description,
            'Type': type,
            'Formula': formula,
            'ComputableConcepts': computableConceptsArray,
            'DependsOn': dependingConceptsArray
        };

        if(type === 'xbrl28:validation') {
            ensureExists(validatedConceptsArray, 'object', 'createNewRule', 'function called without validatedConceptsArray.');
            if(validatedConceptsArray.length === 0) {
                throw new Error('validatedConceptsArray: rule of type "' + type + '" must have at least one validateble concept. Function createNewRule was called with empty validatedConceptsArray.');
            }
            rule.ValidatedConcepts = validatedConceptsArray;
        }
        return rule;
    };

    var validate = function(report, errorMsgPrefix, action, id, label, type, description, formula, computableConceptsArray, dependingConceptsArray, validatedConceptsArray){
        ensureExists(id, 'string', errorMsgPrefix, 'Mandatory Id missing.');
        var existingRule = report.getRule(id);
        if(action === 'Create' && existingRule !== undefined && existingRule !== null){
            throw new Error(errorMsgPrefix + ': Rule with ID "' + id + '" already exists!');
        } else if(action === 'Update' && (existingRule === undefined || existingRule === null)){
            throw new Error(errorMsgPrefix + ': Rule with ID "' + id + '" doesn\'t exist!');
        } else if(action !== 'Create' && action !== 'Update'){
            throw new Error(errorMsgPrefix + ': Unknown action "' + action + '"!');
        }
        ensureExists(label, 'string', errorMsgPrefix, 'Mandatory Label missing.');
        ensureExists(formula, 'string', errorMsgPrefix, 'Cannot store rule with empty source code.');
        ensureExists(computableConceptsArray[0], 'string', errorMsgPrefix, 'Mandatory computable concept missing.');
        for(var i in computableConceptsArray) {
            if(computableConceptsArray.hasOwnProperty(i)) {
                var cname = computableConceptsArray[i];
                ensureConceptName(cname, 'computableConceptsArray', errorMsgPrefix, 'The computable concept name ' + cname + ' is not a valid concept name (correct pattern e.g. fac:Revenues).');
                var cconcept = report.getConcept(cname);
                if (cconcept === undefined || cconcept === null) {
                    throw new Error(errorMsgPrefix + ': the computable concept with name "' + cname + '" does not exist. You need to <b>create this concept</b> or adapt it to an existing one before you can create the rule.');
                }
                var rulesComputableConcepts = report.computableByRules(cname);
                if (rulesComputableConcepts.lenght > 0 && rulesComputableConcepts[0].Id !== id) {
                    throw new Error(errorMsgPrefix + ': A rule which can compute facts for concept "' + cname + '" exists already: "' + rulesComputableConcepts[0].Id + '. Currently, only one rule must be able to compute a fact for a certain concept.');
                }
            }
        }
        if(dependingConceptsArray !== null && typeof dependingConceptsArray === 'object') {
            for (var j in dependingConceptsArray) {
                if(dependingConceptsArray.hasOwnProperty(j)) {
                    var dname = dependingConceptsArray[j];
                    ensureConceptName(dname, 'dependingConceptsArray', errorMsgPrefix, 'The dependency concept name ' + dname + ' is not a valid concept name (correct pattern e.g. fac:Revenues).');
                    var dconcept = report.getConcept(dname);
                    if (dconcept === undefined || dconcept === null) {
                        throw new Error(errorMsgPrefix + ': A concept with name "' + dname + '" does not exist (as used in the dependencies). You need to create this concept or remove it from the dependencies before you can create the rule.');
                    }
                }
            }
        }
        if(validatedConceptsArray !== null && typeof validatedConceptsArray === 'object') {
            for(var x in validatedConceptsArray) {
                if(validatedConceptsArray.hasOwnProperty(x)) {
                    var vname = validatedConceptsArray[x];
                    ensureConceptName(vname, 'validatedConceptsArray', errorMsgPrefix, 'The validated concept name ' + vname + ' is not a valid concept name (correct pattern e.g. fac:Revenues).');
                    var vconcept = report.getConcept(vname);
                    if (vconcept === undefined || vconcept === null) {
                        throw new Error(errorMsgPrefix + ': The validated concept with name "' + vname + '" does not exist. You need to create this concept or adapt it to an existing one before you can create the rule.');
                    }
                }
            }
        }
    };

    Report.prototype.updateRule = function(rule){
        var id = rule.Id;
        var label = rule.Label;
        var language = rule.OriginalLanguage;
        var type = rule.Type;
        var description = rule.Description;
        var formula = rule.Formula;
        var computableConceptsArray = rule.ComputableConcepts;
        var dependingConceptsArray = rule.DependsOn;
        var validatedConceptsArray = rule.ValidatedConcepts;
        validate(this, 'Rule Updating Error', 'Update', id, label, type, description, formula, computableConceptsArray, dependingConceptsArray, validatedConceptsArray);
        if(type === 'xbrl28:formula' && language === undefined){
            this.setFormulaRule(id, label, description, formula, computableConceptsArray, dependingConceptsArray);
        } else if (type === 'xbrl28:validation' && language === undefined) {
            this.setValidationRule(id, label, description, formula, computableConceptsArray, dependingConceptsArray, validatedConceptsArray);
        } else if (language === 'SpreadsheetFormula') {
            var model = this.getModel();
            ensureExists(model, 'object', 'updateRule', 'Report doesn\'t have a model.');

            this.removeRule(id);
            model.Rules.push(rule);
        }
    };

    Report.prototype.createRule = function(rule){
        var id = rule.Id;
        var label = rule.Label;
        var language = rule.OriginalLanguage;
        var type = rule.Type;
        var description = rule.Description;
        var formula = rule.Formula;
        var computableConceptsArray = rule.ComputableConcepts;
        var dependingConceptsArray = rule.DependsOn;
        var validatedConceptsArray = rule.ValidatedConcepts;
        validate(this, 'Rule Creation Error', 'Create', id, label, type, description, formula, computableConceptsArray, dependingConceptsArray, validatedConceptsArray);
        if(type === 'xbrl28:formula' && language === undefined){
            this.setFormulaRule(id, label, description, formula, computableConceptsArray, dependingConceptsArray);
        } else if (type === 'xbrl28:validation' && language === undefined) {
            this.setValidationRule(id, label, description, formula, computableConceptsArray, dependingConceptsArray, validatedConceptsArray);
        } else if (language === 'SpreadsheetFormula') {
            var model = this.getModel();
            ensureExists(model, 'object', 'createRule', 'Report doesn\'t have a model.');

            if(model.Rules === null || model.Rules === undefined) {
                model.Rules = [];
            }
            model.Rules.push(rule);
        }
    };

    Report.prototype.setFormulaRule = function(id, label, description, formula, computableConceptsArray, dependingConceptsArray){
        // sanity checks are done in createNewRule
        var rule = createNewRule(id, label, description, 'xbrl28:formula', formula, computableConceptsArray, dependingConceptsArray, null, this);

        var model = this.getModel();
        ensureExists(model, 'object', 'setFormulaRule', 'Report doesn\'t have a model.');

        if(model.Rules === null || model.Rules === undefined) {
            model.Rules = [];
        }
        if(this.existsRule(id)) {
            this.removeRule(id);
        }
        model.Rules.push(rule);
    };

    Report.prototype.setValidationRule = function(id, label, description, formula, computableConceptsArray, dependingConceptsArray, validatedConceptsArray){
        // sanity checks are done in createNewRule
        var rule = createNewRule(id, label, description, 'xbrl28:validation', formula, computableConceptsArray, dependingConceptsArray, validatedConceptsArray, this);

        var model = this.getModel();
        ensureExists(model, 'object', 'setValidationRule', 'Report doesn\'t have a model.');

        if(model.Rules === null || model.Rules === undefined) {
            model.Rules = [];
        }
        if(this.existsRule(id)) {
            this.removeRule(id);
        }
        model.Rules.push(rule);
    };

    Report.prototype.listValidatingRules = function(concept){

        var result = [];
        var model = this.getModel();
        if (model === null || model === undefined || model.Rules === null || model.Rules === undefined) {
            return result;
        }
        if (concept !== undefined && concept !== null) {
            ensureParameter(concept, 'concept', 'string', 'listValidatingRules');
            result = this.validatedByRules(concept);
        }
        return result;
    };

    Report.prototype.listRules = function(concept, rulesType){

        if(rulesType === undefined || rulesType === null) {
            var result = [];
            var model = this.getModel();
            if (model === null || model === undefined || model.Rules === null || model.Rules === undefined) {
                return result;
            }
            if (concept !== undefined && concept !== null) {
                ensureParameter(concept, 'concept', 'string', 'listRules');
                result = this.computableByRules(concept);
            } else {
                result = model.Rules;
            }
            return result;
        }else if(rulesType === 'xbrl28:formula'){
            return this.listFormulaRules(concept);
        }else if(rulesType === 'xbrl28:validation'){
            return this.listValidationRules(concept);
        }else if(rulesType === 'SpreadsheetFormula'){
            return this.listSpreadsheetRules(concept);
        }
    };

    Report.prototype.listFormulaRules = function(concept){
        var result = [];
        var rules = this.listRules(concept);
        for(var i in rules) {
            var rule = rules[i];
            if(rule.Type === 'xbrl28:formula'){
                result.push(rule);
            }
        }
        return result;
    };

    Report.prototype.listValidationRules = function(concept){
        var result = [];
        var rules = this.listRules(concept);
        for(var i in rules) {
            var rule = rules[i];
            if(rule.Type === 'xbrl28:validation'){
                result.push(rule);
            }
        }
        return result;
    };

    Report.prototype.listSpreadsheetRules = function(concept){
        var result = [];
        var rules = this.listRules(concept);
        for(var i in rules) {
            var rule = rules[i];
            if(rule.OriginalLanguage === 'SpreadsheetFormula'){
                result.push(rule);
            }
        }
        return result;
    };

    return Report;
});
